<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>蓝桥杯</title>
    <link href="/2023/03/20/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    <url>/2023/03/20/%E8%93%9D%E6%A1%A5%E6%9D%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="按键部分"><a href="#按键部分" class="headerlink" title="按键部分"></a>按键部分</h1><p><img src="/img/lqb/0.png"></p><h2 id="独立按键"><a href="#独立按键" class="headerlink" title="独立按键"></a>独立按键</h2><p>代码  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ctrl+c">void BTN()//<br>&#123;<br>    unsigned char dat=P3^0xff;<br>    Trg=dat&amp;(dat^Cont);<br>    Cont=dat;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为初始状态 P3&#x3D;0xff，所以dat &#x3D;0x00，Trg&#x3D;0x00 ，因为0与上任何数都是0，Cont&#x3D;0<br>假设S4按下P3的状态是0xf7，此时 dat &#x3D;0x08 ，Trg&#x3D;0x08，Cont&#x3D;0x08<br>如果长按，则 dat &#x3D;0x08 ，Trg&#x3D;0x00，Cont&#x3D;0x08<br>所以我们可以每10ms就去读一次是否触发，相当于是消抖了。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ctrl+c">unsigned char flag;//定义全局变量<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ctrl+c">void Timer0_Init(void)//1毫秒@11.0592MHz<br>&#123;<br>AUXR |= 0x80;//定时器时钟1T模式<br>TMOD &amp;= 0xF0;//设置定时器模式<br>TL0 = 0xCD;//设置定时初始值<br>TH0 = 0xD4;//设置定时初始值<br>    EA=1;<br>    ET0=1;<br>TR0 = 1;//定时器0开始计时<br>&#125;<br>void Timer0() interrupt 1<br>&#123;<br>    static unsigned char flag_cnt;<br>    flag_cnt++;<br>    if(flag_cnt==10)<br>    &#123;        <br>        flag=1;<br>        flag_cnt=0;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ctrl+c">if(flag)<br>&#123;<br>    BTN();<br>    flag=0;<br>    if(Trg&amp;0x01)//S7<br>    &#123;<br>    <br>    &#125;<br>    else if(Trg&amp;0x02)//S6<br>    &#123;<br> <br>    &#125;<br>    else if(Trg&amp;0x04)//S5<br>    &#123;<br> <br>    &#125;<br>    else if(Trg&amp;0x08)//S4<br>    &#123;<br> <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="矩阵键盘部分"><a href="#矩阵键盘部分" class="headerlink" title="矩阵键盘部分"></a>矩阵键盘部分</h2><p>在开头定义按键值定义成4*4的矩阵。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ctrl+c">uchar code keymap[4][4]=&#123;&#123;7,11,15,19&#125;,&#123;6,10,14,18&#125;,&#123;5,9,13,17&#125;,&#123;4,8,12,16&#125;&#125;;<br>uchar Trg=0,Cont=0,flag=0,dat=0,keyvalue=0,key=0;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ctrl+c">void KBD()<br>&#123;<br>uchar row=0,cloumn=0,i,j;<br>P3=0x0f;P44=0;P42=0;<br>row=P3&amp;0x0f;<br>P3=0xf0;P44=1;P42=1;<br>if(P44 == 0)cloumn = 0x70;<br>else if(P42 == 0)cloumn = 0xb0;<br>elsecloumn = P3 &amp; 0xf0;<br>dat=~(cloumn|row);<br>Trg=dat&amp;(dat^Cont);<br>Cont=dat;<br><br>if(Trg)<br>&#123;<br>for(i = 0; i &lt; 4; i++)<br>for(j = 0; j &lt; 4; j++)<br>if(Trg == (0x80 &gt;&gt; j | 0x01 &lt;&lt; i))<br>&#123;<br>keyvalue = keymap[i][j];<br>key=keyvalue;<br>break;<br>&#125;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/lqb/1.png"><br>分析：当紫色位置按键被按下时，进入检测的代码时会有以下步骤：<br>1.列赋0，行都赋1 即P44、P42、P36、P35为低电平 ，P30-P33都是高电平<br>2.将P3和0X0F进行“与” 操作，得到具体哪一行被按下<br>3.列赋1，行都赋0 ，即P44、P42、P36、P35为高电平 ，P30-P33都是低电平<br>4.判断是哪列被按下， 将值赋给cloumn  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">三行判断式分析：</span><br><span class="hljs-string">第一次：</span><br>        <span class="hljs-string">row</span> <span class="hljs-string">=(0000</span> <span class="hljs-number">1101</span><span class="hljs-string">)</span> <span class="hljs-string">&amp;(0000</span> <span class="hljs-number">1111</span><span class="hljs-string">)</span> <span class="hljs-string">=0000</span> <span class="hljs-number">1101</span><br>        <span class="hljs-string">cloumn</span> <span class="hljs-string">=</span> <span class="hljs-number">0xb0</span><br>        <span class="hljs-string">dat</span> <span class="hljs-string">=</span> <span class="hljs-string">~(row|cloumn)=~(</span> <span class="hljs-string">(1011</span> <span class="hljs-number">0000</span><span class="hljs-string">)|</span> <span class="hljs-number">0000 </span><span class="hljs-number">1101</span><span class="hljs-string">)</span> <span class="hljs-string">=</span> <span class="hljs-number">0100 </span><span class="hljs-number">0010</span> <span class="hljs-string">=</span> <span class="hljs-number">0x72</span><br>        <span class="hljs-string">Trg</span> <span class="hljs-string">=</span> <span class="hljs-string">(0x72)</span> <span class="hljs-string">&amp;</span> <span class="hljs-string">(0x72^0x00)</span> <span class="hljs-string">=</span> <span class="hljs-number">0x72</span>   <span class="hljs-string">(异或符号^)</span><br>        <span class="hljs-string">Cont</span> <span class="hljs-string">=</span> <span class="hljs-string">dat</span> <span class="hljs-string">=0x72</span> <br><span class="hljs-string">第二次（紫色按钮还处于按下状态）：</span><br>        <span class="hljs-string">row</span> <span class="hljs-string">=(0000</span> <span class="hljs-number">1101</span><span class="hljs-string">)</span> <span class="hljs-string">&amp;(0000</span> <span class="hljs-number">1111</span><span class="hljs-string">)</span> <span class="hljs-string">=0000</span> <span class="hljs-number">1101</span><br>        <span class="hljs-string">cloumn</span> <span class="hljs-string">=</span> <span class="hljs-number">0xb0</span><br>        <span class="hljs-string">dat</span> <span class="hljs-string">=</span> <span class="hljs-string">~(row|cloumn)=~(</span> <span class="hljs-string">(1011</span> <span class="hljs-number">0000</span><span class="hljs-string">)|</span> <span class="hljs-number">0000 </span><span class="hljs-number">1101</span><span class="hljs-string">)</span> <span class="hljs-string">=</span> <span class="hljs-number">0100 </span><span class="hljs-number">0010</span> <span class="hljs-string">=</span> <span class="hljs-number">0x72</span><br>        <span class="hljs-string">Trg</span> <span class="hljs-string">=</span> <span class="hljs-string">(0x72)</span> <span class="hljs-string">&amp;</span> <span class="hljs-string">(0x72^0x72)</span> <span class="hljs-string">=0x00</span><br>        <span class="hljs-string">Cont</span> <span class="hljs-string">=</span> <span class="hljs-string">dat</span> <span class="hljs-string">=0x72</span><br></code></pre></td></tr></table></figure><p>所以这个三行判断式可以检测长按和短按，通过十毫秒的检测 “延时” ，可以达到检测准确的效果。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ctrl+c">void Timer0_Init(void)//1毫秒@11.0592MHz<br>&#123;<br>AUXR |= 0x80;//定时器时钟1T模式<br>TMOD &amp;= 0xF0;//设置定时器模式<br>TL0 = 0xCD;//设置定时初始值<br>TH0 = 0xD4;//设置定时初始值<br>    EA=1;<br>    ET0=1;<br>TR0 = 1;//定时器0开始计时<br>&#125;<br>void Timer0() interrupt 1<br>&#123;<br>    static unsigned char flag_cnt;<br>    flag_cnt++;<br>    if(flag_cnt==10)<br>    &#123;        <br>        flag=1;<br>        flag_cnt=0;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用模板如下  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ctrl+c">if(flag)<br>&#123;<br>KBD();<br>flag=0;<br>if(key==4) //S4<br>&#123;<br>key=0;<br>&#125;<br>else if(key==5) //S5<br>&#123;<br>key=0;<br>&#125;<br>else if(key==9) //S9<br>&#123;<br>key=0;<br>&#125;<br>else if(key==8) //S8<br>&#123;<br>key=0;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="矩阵键盘化简写法"><a href="#矩阵键盘化简写法" class="headerlink" title="矩阵键盘化简写法"></a>矩阵键盘化简写法</h2><p>蓝桥杯的矩阵键盘考法一般为四个相邻的键，只有四根线控制，那么是不是可以不用把所有的情况都写出来呢。<br>假设使用S4、S5、S8、S9四个按键，涉及到的IO分别为P42、P43、P32、P33。通过这四个IO的组合，再由状态机去检测按下和长按。<br>前六行就是对一个状态的赋值，和常规的矩阵键盘的检测方式没啥区别。<br>实际部分就是下两行对状态的判断。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs routeros">void BTN()<br>&#123;<br>uchar dat;<br>P32 = 0;P33 = 0;P42 = 1;P44 = 1;<br><span class="hljs-keyword">if</span>(P42 == 0)<span class="hljs-attribute">dat</span>=0x40;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(P44 == 0) <span class="hljs-attribute">dat</span>=0x80;<br>P32 = 1;P33 = 1;P42 = 0;P44 = 0;<br><span class="hljs-keyword">if</span>(P32 == 0)<span class="hljs-attribute">dat</span>=dat|0x01 ;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(P33 == 0) <span class="hljs-attribute">dat</span>=dat|0x02;<br>Trg = dat&amp;(dat^Cont);<br>Cont = dat;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="DS18B20"><a href="#DS18B20" class="headerlink" title="DS18B20"></a>DS18B20</h1><p>DS18B20作为单总线协议的器件，只需要一根数据线就能进行通讯<br>查看底板的原理图可以找到DS18B20，这是单总线的接法，数据通过P1.4进行传输。</p><h2 id="修改官方驱动文件"><a href="#修改官方驱动文件" class="headerlink" title="修改官方驱动文件"></a>修改官方驱动文件</h2><p><img src="/img/lqb/2.png"><br>赛点数据包给了最底层的代码，所以我们只需要编写驱动就行了。<br><font color ="ff00ff">因为赛点资源包给的底层已经可以直接使用所有这里不需要再改些什么。</font>  </p><h2 id="DS18B20数据手册部分"><a href="#DS18B20数据手册部分" class="headerlink" title="DS18B20数据手册部分"></a>DS18B20数据手册部分</h2><p>以下是温度寄存器的格式最低的四位是小数部分，最高五位是符号位，针对此，可以对读出的数据进行处理来得到所需要的精度的数据。<br><img src="/img/lqb/3.png"><br>以下是输出数据和和对应温度的转换。<br><img src="/img/lqb/4.png"><br><font color ="dddd00">默认出厂时12位精度的。</font>对应的转换就是将读出的数据拼接<em>0.0625，但是为了更加方便的显示，更具精度要求进行倍数扩大。例如：<br>需求精度是小数点后两位，就在读出数据后</em>6.25。<br>需求精度是小数点后三位，就在读出数据后*62.5。<br>以下是从数据手册截取的，只用于读取温度数据的指令。  </p><table><thead><tr><th align="center">MASTER MODE</th><th align="center">DATA (LSB FIRST)</th><th align="center">COMMENTS</th></tr></thead><tbody><tr><td align="center">Tx</td><td align="center">CCh</td><td align="center">Master issues Skip ROM command.（主机发送跳过ROM指令）</td></tr><tr><td align="center">Tx</td><td align="center">44h</td><td align="center">Master issues Convert T command.（主机发送 只转换一次温度而无其他数据指令）</td></tr><tr><td align="center">Tx</td><td align="center">BEh</td><td align="center">Master issues Read Scratchpad command.（主机发送 读取暂存器的内容指令）</td></tr></tbody></table><h2 id="实际操作部分"><a href="#实际操作部分" class="headerlink" title="实际操作部分"></a>实际操作部分</h2><p><img src="/img/lqb/5.png"><br>根据流程图来说<br>第一步是初始化，确认总线上存在DS18B20设备<br>发送<font color="dd0000">0XCC</font> 跳过内存命令<br>发送<font color ="dd0000">0X44</font>（温度转换命令）<br>等待转换完成用延时完成<br>复位，使用的也是初始化函数<br>发送<font color="dd0000">0XCC</font> 跳过内存命令<br>发送<font color ="dd0000">0XBE</font>（输出温度数据命令）主机开始接收16位数据  </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ctrl+c">long read_tempf()<br>&#123;<br>uchar low,high;<br>    long temp;<br>init_ds18b20();<br>Write_DS18B20(0xcc);<br>Write_DS18B20(0x44);<br>Delay_OneWire(200);  <br>init_ds18b20();<br>Write_DS18B20(0xcc);<br>Write_DS18B20(0xbe);<br>low =Read_DS18B20();<br>high=Read_DS18B20();<br>temp=high&amp;0x0f;<br>temp=temp&lt;&lt;8;<br>temp=temp|low;<br>temp=temp*6.25; //根据精度要求修改<br>return temp ;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数码管显示"><a href="#数码管显示" class="headerlink" title="数码管显示"></a>数码管显示</h2><p>只需要在小数点位置添加 异或上0X80即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs ctrl+c">void display()<br>&#123;<br>uchar dis[8],i;<br>dis[0] = 0x87;<br>dis[1] = LEDchar[0];<br>dis[2] = LEDchar[0];<br>dis[3] = LEDchar[temp/10000%10];<br>dis[4] = LEDchar[temp/1000%10];<br>dis[5] = LEDchar[temp/100%10]^0X80;<br>dis[6] = LEDchar[temp/10%10];<br>dis[7] = LEDchar[temp%10];<br><br>for(i = 1;i&lt;8;i++)<br>&#123;<br>if(dis[i] == LEDchar[0])<br>dis[i] = 0xff;<br>else break;<br>&#125;<br>for(i = 0;i&lt;8;i++)<br>&#123;<br>P2 = 0XC0 ;<br>P0 = 1&lt;&lt;i ;<br>P2 = 0XE0 ;<br>P0 = dis[i];<br>Delay100us(); //移植别漏了<br>P0=0xff;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="DS1302"><a href="#DS1302" class="headerlink" title="DS1302"></a>DS1302</h1><p>DS1302作为时钟芯片，采用SPI通信。  </p><h2 id="数据手册"><a href="#数据手册" class="headerlink" title="数据手册"></a>数据手册</h2><p>需要注意的只有寄存器的地址，底层驱动官方以及提供。<br><img src="/img/lqb/6.png"></p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>在数据手册第六页有这样一行文字  </p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">The <span class="hljs-built_in">time</span> <span class="hljs-keyword">and</span> calendar information is obtained <span class="hljs-keyword">by</span> reading <span class="hljs-keyword">the</span> appropriate register <span class="hljs-keyword">bytes</span>.Table <span class="hljs-number">3</span> illustrates <span class="hljs-keyword">the</span> RTC registers.The <span class="hljs-built_in">time</span> <span class="hljs-keyword">and</span> calendar are <span class="hljs-built_in">set</span> <span class="hljs-keyword">or</span> initialized <span class="hljs-keyword">by</span> writing <span class="hljs-keyword">the</span> appropriate register <span class="hljs-keyword">bytes</span>.The contents <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> <span class="hljs-built_in">time</span> <span class="hljs-keyword">and</span> calendar registers are <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> binary-coded decimal (BCD) <span class="hljs-built_in">format</span>.<br></code></pre></td></tr></table></figure><p>翻译过来就是: <font color = "ff28ff">通过读取适当的寄存器字节来获得时间和日历信息。表3说明了RTC寄存器。时间和日历通过写入适当的寄存器字节来设置或初始化。时间寄存器和日历寄存器的内容是二进制编码的十进制(BCD)格式。</font><br>十进制转BCD码：BCD&#x3D;DEC&#x2F;10 * 16+DEC%10; （2位BCD）体现在代码中就是  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ctrl+c">void set_Time(unsigned char hor,unsigned char min,unsigned char sec,unsigned char year,unsigned char month,unsigned char date)<br>&#123;<br>Write_Ds1302_Byte(0x8e,0x00);<br>Write_Ds1302_Byte(0x80,(sec/10)*16+sec%10);<br>Write_Ds1302_Byte(0x82,(min/10)*16+min%10);<br>Write_Ds1302_Byte(0x84,(hor/10)*16+hor%10);<br><br>Write_Ds1302_Byte(0x8c,(year/10)*16+year%10);<br>Write_Ds1302_Byte(0x88,(month/10)*16+month%10);<br>Write_Ds1302_Byte(0x86,(date/10)*16+date%10);<br>Write_Ds1302_Byte(0x8e,0x80);<br>&#125;<br></code></pre></td></tr></table></figure><p>BCD码转十进制：DEC&#x3D;BCD&#x2F;16 * 10+BCD%16; （2位BCD）在读取数据后显示  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ctrl+c">void read()<br>&#123;<br>//unsigned char year,mon,date,day,hour,min,sec,year1,mon1,date1,day1,hour1,min1,sec1;全局变量<br>year1=Read_Ds1302_Byte(0x8d);<br>mon1=Read_Ds1302_Byte(0x89);<br>date1=Read_Ds1302_Byte(0x87);<br>hour1=Read_Ds1302_Byte(0x85);<br>min1=Read_Ds1302_Byte(0x83);<br>sec1=Read_Ds1302_Byte(0x81);<br>year=(year1/16)*10+ year1%16;<br>mon=(mon1/16)*10  + mon1%16;<br>date=(date1/16)*10+ date1%16;<br>hour=(hour1/16)*10+hour1%16;<br>min=(min1/16)*10+min1%16;<br>sec=(sec1/16)*10+sec1%16;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="EEPROM"><a href="#EEPROM" class="headerlink" title="EEPROM"></a>EEPROM</h1><p>EEPROM作为IIC接口的存储芯片，官方已经提供了IIC驱动的底层代码，需要做的就是根据具体的器件编写对应的驱动。  </p><h2 id="芯片手册"><a href="#芯片手册" class="headerlink" title="芯片手册"></a>芯片手册</h2><h3 id="器件地址"><a href="#器件地址" class="headerlink" title="器件地址"></a>器件地址</h3><p>根据芯片手册可知器件地址是由 固定的四位数值，和可变动的四位组成的。<font color = "ff28ff">其中A2 A1 A0 已经通过板子接地确认，最后一位是读写位（写0，读1）</font><br><img src="/img/lqb/7.png"></p><h3 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h3><p>芯片手册中提供的写操作时序如下所示：<br><font color = "ff28ff">START</font>下方指的是起始信号，对应蓝桥杯底层驱动的 <font color = "ff28ff">IIC_Start() </font>函数<br><font color = "ff28ff">DEVICE ADDRESS</font> 从MSB(高位)到LSB（低位）共七位再加上读写位共八位，也就是需要向SDA（数据线）发送八位地址，通过官方提供的<font color = "ff28ff">IIC_SendByte()</font>函数中传入地址参数，就会向SDA发送八位地址。<br><font color = "ff28ff">ACK</font>等待应答，对应<font color = "ff28ff">IIC_WaitAck()</font>函数<br><font color = "ff28ff">WORD ADDRESS</font>将数据要存储到的地址发送到SDA数据线上。对应使用<font color = "ff28ff">IIC_SendByte()</font>函数。<br><font color = "ff28ff">ACK</font>等待应答，对应<font color = "ff28ff">IIC_WaitAck()</font>函数<br><font color = "ff28ff">DATA</font>将数据发送到SDA数据线上。对应使用<font color = "ff28ff">IIC_SendByte()</font>函数。<br><font color = "ff28ff">ACK</font>等待应答，对应<font color = "ff28ff">IIC_WaitAck()</font>函数<br><font color = "ff28ff">STOP</font>停止信号，对应使用<font color = "ff28ff">IIC_Stop()</font>函数<br><img src="/img/lqb/8.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ctrl+c">void write_e2prom(unsigned char add,unsigned char date)<br>&#123;<br>IIC_Start();<br>IIC_SendByte(0xa0);<br>IIC_WaitAck();<br>IIC_SendByte(add);<br>IIC_WaitAck();<br>IIC_SendByte(date);<br>IIC_WaitAck();<br>IIC_Stop();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h3><p>读操作的<font color = "ff28ff">DUMMY WRITE</font>部分与写操作一致，这里不再赘述。<br><font color = "ff28ff">START</font>下方指的是起始信号，对应蓝桥杯底层驱动的 <font color = "ff28ff">IIC_Start() </font>函数<br><font color = "ff28ff">DEVICE ADDRESS</font> 从MSB(高位)到LSB（低位）共七位再加上读写位共八位，也就是需要向SDA（数据线）发送八位地址，通过官方提供的<font color = "ff28ff">IIC_SendByte()</font>函数中传入地址参数，就会向SDA发送八位地址。<br><font color = "ff28ff">ACK</font>等待应答，对应<font color = "ff28ff">IIC_WaitAck()</font>函数<br><font color = "ff28ff">DATA</font>EEPROM将数据发送到SDA数据线上。由主机进行采集对应使用<font color = "ff28ff">IIC_RecByte()</font>函数<br><font color = "ff28ff">STOP</font>停止信号，对应使用<font color = "ff28ff">IIC_Stop()</font>函数<br><img src="/img/lqb/9.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ctrl+c">unsigned char read_e2prom(unsigned char add)<br>&#123;<br>unsigned char temp;<br>IIC_Start();<br>IIC_SendByte(0xa0);<br>IIC_WaitAck();<br>IIC_SendByte(add);<br>IIC_WaitAck();<br><br>IIC_Start();<br>IIC_SendByte(0xa1);<br>IIC_WaitAck();<br>temp = IIC_RecByte();<br>IIC_Stop();<br>return temp ;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="读写注意事项"><a href="#读写注意事项" class="headerlink" title="读写注意事项"></a>读写注意事项</h3><p>在写入一个数据之后，需要稳定SDA线后再读取数据，否则会写入失败，自然不能读取成功。<br>这里使用延时10Ms的方式（若是读取还是不正确，可以考虑增加延时时间）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ctrl+c">write_e2prom(0x00,0x01);<br>Delay10ms();<br>read_temp = read_e2prom(0x00);<br></code></pre></td></tr></table></figure><h1 id="PCF8591"><a href="#PCF8591" class="headerlink" title="PCF8591"></a>PCF8591</h1><p>PCF8591作为板载的AD&#x2F;DA芯片，输入通道有四个分别是AIN0、AIN1、AIN2、AIN3，其中AIN1和AIN3分别接到光敏电阻和滑动变阻器上。也是最常用的两个测量功能。DA输出脚在板子右侧引出的排针处。 </p><h2 id="芯片手册-1"><a href="#芯片手册-1" class="headerlink" title="芯片手册"></a>芯片手册</h2><p>PCF8591器件地址由固定的四位和可变的四位组成，A2、A1、A0已经接地，器件地址变成了0x90加上读写位。<br><img src="/img/lqb/10.png"><br>PCF8591的八位控制器控制内容如下（msb-&gt;lsb）：<br>第七位<font color = "ff28ff">ANALOGUE OUTPUT ENABLE FLAG</font>是一个I2C寄存器中的标志位，它表示是否启用模拟输出通道（Analog Output Channel）。PCF8591芯片中的ANALOGUE OUTPUT ENABLE FLAG是一个I2C寄存器中的标志位，它表示是否启用模拟输出通道（Analog Output Channel）。也就是所说的DA功能<br>第六和五位<font color = "ff28ff">ANALOGUE INPUT PROGRAMMING</font>模拟输入编程为单端或差分输入<br>第三位<font color = "ff28ff">AUTO-INCREMENT FLAG</font>是一个I2C寄存器中的标志位，它表示是否启用自动增量模式（Auto-Increment Mode）。<br>第二、一位表示使用哪个通道。<br><img src="/img/lqb/11.png"><br>上电复位后，控制寄存器的所有位都复位为逻辑0。为了省电，D&#x2F;A转换器和振荡器被禁用。模拟输出被切换到高阻抗状态。<br>需要对芯片进行配置，根据题目要求进行配置，若是题目要求A&#x2F;D、D&#x2F;A同时进行，则将第七位置一，再选择对应A&#x2F;D通道，若是需要采集多通道A&#x2F;D数据，可以开启<font color = "ff28ff">AUTO-INCREMENT FLAG</font>自动增加通道，实现自动采集，但多通道数据需要对芯片发出的第一次数据进行检测，如果是0X80则说明通道0的数据马上开始输出了。<br><img src="/img/lqb/12.png"><br>设置完芯片可以开始对输出数据进行读取。  </p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p>配置芯片，这里配置为0X43代表通道三和DA功能。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ctrl+c">void write_dac(unsigned char dat)<br>&#123;<br>IIC_Start();<br>IIC_SendByte(0x90);<br>IIC_WaitAck();<br>IIC_SendByte(0x43);<br>IIC_WaitAck();<br>IIC_SendByte(dat);<br>IIC_WaitAck();<br>IIC_Stop();<br>&#125;<br></code></pre></td></tr></table></figure><p>直接读取单通道内容，所以不需要区分通道数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ctrl+c">unsigned char read_ad()<br>&#123;<br>unsigned char temp;<br>IIC_Start();<br>IIC_SendByte(0x91);<br>IIC_WaitAck();<br>temp = IIC_RecByte();<br>return temp;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="超声波"><a href="#超声波" class="headerlink" title="超声波"></a>超声波</h1><h2 id="超声波的原理"><a href="#超声波的原理" class="headerlink" title="超声波的原理"></a>超声波的原理</h2><p>超声波发射器向某一方向发射超声波，在发射时刻的同时开始计时，超声波在空气中传播，途中碰到障碍物就立即返回来，超声波接收器收到反射波就立即停止计时。超声波在空气中的传播速度为340m&#x2F;s，根据计时器记录的时间t，就可以计算出发射点距障碍物的距离(s)，即：s&#x3D;340t&#x2F;2 。这就是所谓的时间差测距法。  </p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><p>使用PCA不占用过多的定时器资源。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs ctrl+c">sbit TX=P1^0;<br>sbit RX=P1^1;<br>//PCA 初始化<br>CMOD = 0x08;<br>CCON = 0x00;<br><br>void Delay13us()//@12.000MHz<br>&#123;<br>unsigned char i;<br><br>_nop_();<br>_nop_();<br>i = 39;<br>while (--i);<br>&#125;<br>void send_wave()<br>&#123;<br>unsigned char i = 8;<br>while(i)<br>&#123;<br>TX = 1;<br>Delay13us();<br>TX = 0;<br>Delay13us();<br>i--;<br>&#125;<br>&#125;<br>void get_distance()<br>&#123;<br>//unsigned int time;<br>send_wave();<br>CH = 0;CL = 0;<br>CR = 1;<br>while( RX &amp;&amp; (CF == 0));<br>CR = 0;<br>if(CF)<br>&#123;<br>CF = 0;<br>&#125;<br>else<br>&#123;<br>time = CH*256+CL;<br>distance = (unsigned int)(0.017*time/12); //cm<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>推荐单独开一个定时器中断进行距离检测。<br>一共三个定时器，资源还是比较丰富的。</p><h1 id="串口"><a href="#串口" class="headerlink" title="串口"></a>串口</h1><p>51的串口是全双工的，只需要 Tx 和 Rx 两根线。<br>蓝桥杯的串口，主要考察的就是一个发送和接收。  </p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化串口，可以使用STC-ISP工具自动生成波特率。<br><img src="/img/lqb/16.png"><br>也可以根据需要将波特率发生器修改为其它定时器。<br><img src="/img/lqb/17.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ctrl+c">void UartInit(void)//9600bps@11.0592MHz<br>&#123;<br>SCON = 0x50;//8位数据,可变波特率<br>AUXR |= 0x40;//定时器时钟1T模式<br>AUXR &amp;= 0xFE;//串口1选择定时器1为波特率发生器<br>TMOD &amp;= 0x0F;//设置定时器模式<br>TL1 = 0xE0;//设置定时初始值<br>TH1 = 0xFE;//设置定时初始值<br>ET1 = 0;//禁止定时器中断<br>TR1 = 1;//定时器1开始计时<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void <span class="hljs-constructor">SendByte(<span class="hljs-params">unsigned</span> <span class="hljs-params">char</span> <span class="hljs-params">dat</span>)</span><br>&#123;<br><span class="hljs-keyword">while</span> (busy);           <span class="hljs-comment">//Wait for the completion of the previous data is sent</span><br>    ACC = dat;              <span class="hljs-comment">//Calculate the even parity bit P (PSW.0)</span><br>busy = <span class="hljs-number">1</span>;<br>    SBUF = ACC;             <span class="hljs-comment">//Send data to UART buffer</span><br>&#125;<br>void <span class="hljs-constructor">SendString(<span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">s</span>)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (*s)              <span class="hljs-comment">//Check the end of the string</span><br>    &#123;<br>        <span class="hljs-constructor">SendByte(<span class="hljs-operator">*</span><span class="hljs-params">s</span><span class="hljs-operator">++</span>)</span>;     <span class="hljs-comment">//Send current char and increment string ptr</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>重定向到串口</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">char <span class="hljs-built_in">putchar</span>(char ch)<br>&#123;<br><span class="hljs-built_in">SendByte</span>(ch);<br>return ch;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="中断接收"><a href="#中断接收" class="headerlink" title="中断接收"></a>中断接收</h2><p>如果说，定时器的定时频率过高会影响串口的接收，就需要提高串口的中断优先级.</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">PS</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs awk">void ServiceUart() interrupt <span class="hljs-number">4</span><br>&#123;<br><span class="hljs-keyword">if</span>(RI)<br>&#123;<br>RI=<span class="hljs-number">0</span>;<br>Rdat=SBUF;<br><span class="hljs-keyword">if</span>(Rdat != <span class="hljs-string">&#x27;\n&#x27;</span>)<br>&#123;<br>Recv[Rcnt] = Rdat;<br>Rcnt++;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>Recv[Rcnt]=<span class="hljs-string">&#x27;\n&#x27;</span>;<span class="hljs-regexp">//</span>因为判断漏掉了<br>Rcnt=<span class="hljs-number">0</span>;<br>rx_flag=<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (TI)<br>    &#123;<br>        TI = <span class="hljs-number">0</span>;                 <span class="hljs-regexp">//</span>清除TI位<br>        busy = <span class="hljs-number">0</span>;               <span class="hljs-regexp">//</span>清忙标志<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="NE555"><a href="#NE555" class="headerlink" title="NE555"></a>NE555</h1>]]></content>
    
    
    <categories>
      
      <category>蓝桥杯</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fpga_demo</title>
    <link href="/2023/02/12/fpga-demo/"/>
    <url>/2023/02/12/fpga-demo/</url>
    
    <content type="html"><![CDATA[<h1 id="newproject"><a href="#newproject" class="headerlink" title="newproject"></a>newproject</h1><p>下载软件，教育版即可。  </p><h2 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h2><p>点击左上角，如下顺序操作后，点击ok。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">file</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">new</span>-&gt;</span>fpga design project<br></code></pre></td></tr></table></figure><p>出现如下界面<br><img src="/img/fpga_demo/project/0.png"><br>我的配置如下<br><img src="/img/fpga_demo/project/1.png"></p><p>点击next<br>选择芯片型号<br><img src="/img/fpga_demo/project/2.png"><br>点击型号选中，点击next-&gt;finish</p><p>点击此图标<br><img src="/img/fpga_demo/project/3.png"><br>选择使用的语言，这里是verilog<br><img src="/img/fpga_demo/project/4.png"><br>输入文件名称，这里存为led<br><img src="/img/fpga_demo/project/5.png"><br>点击ok后工程会添加刚创建的文件  </p><h1 id="led"><a href="#led" class="headerlink" title="led"></a>led</h1><p>实现：led闪烁</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> led(<br>    <span class="hljs-keyword">input</span> sys_clk,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> led = <span class="hljs-number">1</span><br>);<br><br><span class="hljs-keyword">reg</span> [<span class="hljs-number">23</span>:<span class="hljs-number">0</span>] counter = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> sys_clk) <span class="hljs-keyword">begin</span><br>    counter &lt;= counter + <span class="hljs-number">1&#x27;b1</span>;<br>    <span class="hljs-keyword">if</span>( counter == <span class="hljs-number">24&#x27;d1349_9999</span> ) <span class="hljs-keyword">begin</span><br>        led &lt;= ~led;<br>        counter &lt;= <span class="hljs-number">24&#x27;d0</span>;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>点击 synthesize<br><img src="/img/fpga_demo/led/b_0.png"><br>绑定管脚<br>点击floorplanner<br>输入的是原理图上对应的管脚<br><img src="/img/fpga_demo/led/b_1.png"><br>点击 place &amp; route 布线</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>点击<br><img src="/img/fpga_demo/led/0.png"><br>点击save<br><img src="/img/fpga_demo/led/1.png"><br>下载到sram mode<br><img src="/img/fpga_demo/led/2.png"><br>效果如下<br><img src="/img/fpga_demo/led/11.gif">  </p><h2 id="在线逻辑分析仪"><a href="#在线逻辑分析仪" class="headerlink" title="在线逻辑分析仪"></a>在线逻辑分析仪</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>添加gao配置文件，一路next<br><img src="/img/fpga_demo/led/3.png"><br><img src="/img/fpga_demo/led/4.png"><br><img src="/img/fpga_demo/led/5.png"><br><img src="/img/fpga_demo/led/6.png"><br>添加触发信号<br><img src="/img/fpga_demo/led/7.png"><br><img src="/img/fpga_demo/led/8.png"><br>配置如下<br><img src="/img/fpga_demo/led/9.png"><br>采样信号<br><img src="/img/fpga_demo/led/10.png"><br>重新编译一下<br>延时太长，这里将延时改小</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> led(<br>    <span class="hljs-keyword">input</span> sys_clk,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> led<br>);<br><br><span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] counter;<br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> sys_clk) <span class="hljs-keyword">begin</span><br>    counter &lt;= counter + <span class="hljs-number">1&#x27;b1</span>;<br>    <span class="hljs-keyword">if</span>( counter == <span class="hljs-number">4&#x27;d9</span> )<span class="hljs-keyword">begin</span><br>        led &lt;= ~led;<br>        counter &lt;= <span class="hljs-number">4&#x27;d0</span>;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>点击 place &amp; route 重新编译一下</p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p><img src="/img/fpga_demo/led/11.png"><br>点击enable programer<br><img src="/img/fpga_demo/led/12.png"><br>依次点击箭头所指<br><img src="/img/fpga_demo/led/13.png"><br>出现波形<br><img src="/img/fpga_demo/led/14.png"><br>放大可以看到波形是10us反转一次<br><img src="/img/fpga_demo/led/15.png"><br>在板子上无法观察到，板子led恒亮</p><h1 id="key"><a href="#key" class="headerlink" title="key"></a>key</h1><p>实现：按键输入led电平反转</p><h2 id="按键消抖"><a href="#按键消抖" class="headerlink" title="按键消抖"></a>按键消抖</h2><p>按键通过延时进行消抖</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> key(<br><span class="hljs-keyword">input</span> sys_clk,<span class="hljs-comment">//系统时钟</span><br><span class="hljs-keyword">input</span> sys_rst_n,<span class="hljs-comment">//系统复位信号</span><br><span class="hljs-keyword">input</span> key,<span class="hljs-comment">//按键输入信号</span><br><span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> led<span class="hljs-comment">//led状态输出信号</span><br>);<br><br><span class="hljs-keyword">reg</span> [<span class="hljs-number">19</span>:<span class="hljs-number">0</span>] count ;<span class="hljs-comment">//计数寄存器</span><br><span class="hljs-comment">//这个按键消抖的思想是这样的：寻找按下后10ms稳定的按键低电平信号</span><br><span class="hljs-comment">//当按键未按下时，count的值是0 不开始计数，当按键在按下时 0 - 1 抖动的时候不计时 </span><br><span class="hljs-comment">//当检测到按键按下时 也就是key = 0 且 count小于计数最大值时，这时候count开始计数</span><br><span class="hljs-comment">//</span><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> sys_clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> sys_rst_n )<span class="hljs-keyword">begin</span><br><span class="hljs-keyword">if</span>(!sys_rst_n)<span class="hljs-comment">//复位</span><br>count &lt;= <span class="hljs-number">0</span> ;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key == <span class="hljs-number">1&#x27;b1</span> )<span class="hljs-comment">//按键在未按下或者抖动状态时 计数值都被清空 </span><br>count &lt;= <span class="hljs-number">0</span> ; <br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(count == <span class="hljs-number">20&#x27;d49_9999</span> &amp;&amp; key == <span class="hljs-number">1&#x27;b0</span>) <span class="hljs-comment">// 按键被按下处于消抖后稳定的位置 且计时时间恰好等于需要时间 后 count 给自己赋值 </span><br>count &lt;= count ;<span class="hljs-comment">//计时有效时长维持在50 0000</span><br><span class="hljs-keyword">else</span> <span class="hljs-comment">//count &lt; cnt_max  &amp;&amp; key = 0 count &gt; cnt_max</span><br>count &lt;= count + <span class="hljs-number">1</span> ;<span class="hljs-comment">//</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> sys_clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> sys_rst_n)<span class="hljs-keyword">begin</span><br><span class="hljs-keyword">if</span> (!sys_rst_n) <span class="hljs-comment">//</span><br>led  &lt;= <span class="hljs-number">1</span> ;<span class="hljs-comment">//</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(count == <span class="hljs-number">20&#x27;d49_9999</span> -<span class="hljs-number">1&#x27;b1</span> )<span class="hljs-comment">//在判断有效时需要将值减去几个单位</span><br>led &lt;=  ~led ; <span class="hljs-comment">//</span><br><span class="hljs-keyword">else</span>  <span class="hljs-comment">//</span><br>led &lt;=    led;<span class="hljs-comment">//</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h1 id="tube"><a href="#tube" class="headerlink" title="tube"></a>tube</h1><p>实验：实现电子时钟，显示时分秒，在六位数码管上分别显示时分秒</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>在需要一个计数值来计时，单独出一个模块，根据逻辑写时分秒进位，和数码管的显示 作为一个模块，最后是一个顶层模块一共三个。</p><h3 id="计数模块"><a href="#计数模块" class="headerlink" title="计数模块"></a>计数模块</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> cnt(<br><span class="hljs-keyword">input</span> sys_clk,<span class="hljs-comment">//系统输入</span><br><span class="hljs-keyword">input</span> sys_rst_n,<span class="hljs-comment">//系统复位</span><br><span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> flag,<span class="hljs-comment">//一秒输出高电平维持一个周期作为秒自加信号</span><br><span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> flag_div<span class="hljs-comment">//0.016秒输出一个高电平作为 数码管位选位移信号，至少是1/6的flag时间</span><br>);<br><br><span class="hljs-keyword">parameter</span> cnt_max  = <span class="hljs-number">5000_0000</span> ;<span class="hljs-comment">//自加最大值</span><br><span class="hljs-comment">//parameter cnt_max  = 31&#x27;d50 ;//仿真是自加最大值</span><br><span class="hljs-comment">//parameter cnt_div_max  = 4&#x27;d8;//方针是分配自加最大值</span><br><span class="hljs-keyword">parameter</span> cnt_div_max  = <span class="hljs-number">17&#x27;d80000</span>;<span class="hljs-comment">//分频自加最大值</span><br><span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] cnt;<span class="hljs-comment">//</span><br><span class="hljs-keyword">reg</span> [<span class="hljs-number">16</span>:<span class="hljs-number">0</span>] cnt_div6;<span class="hljs-comment">//</span><br><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> sys_clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> sys_rst_n ) <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">if</span>(!sys_rst_n)<span class="hljs-comment">//复位</span><br>cnt &lt;= <span class="hljs-number">0</span> ;<span class="hljs-comment">//cnt清零</span><br><span class="hljs-keyword">else</span><span class="hljs-keyword">if</span>(cnt &lt; cnt_max - <span class="hljs-number">1&#x27;b1</span> ) <span class="hljs-keyword">begin</span><br>cnt &lt;= cnt + <span class="hljs-number">1&#x27;b1</span> ;<span class="hljs-comment">//当cnt未计到最大值时 一直自加</span><br>flag &lt;= <span class="hljs-number">1&#x27;b0</span>;<span class="hljs-comment">//秒自加信号一直是0</span><br><span class="hljs-keyword">end</span> <br><span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>cnt  &lt;= <span class="hljs-number">31&#x27;b0</span>;<span class="hljs-comment">//当cnt计到最大值时，cnt清空</span><br>flag &lt;= <span class="hljs-number">1&#x27;b1</span>;<span class="hljs-comment">//自加标志位 置1</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> sys_clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> sys_rst_n ) <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">if</span>(!sys_rst_n)<span class="hljs-comment">//复位</span><br>cnt_div6 &lt;= <span class="hljs-number">0</span> ;<span class="hljs-comment">//cnt清零</span><br><br><span class="hljs-keyword">else</span><span class="hljs-keyword">if</span>(cnt_div6 &lt; cnt_div_max - <span class="hljs-number">1&#x27;b1</span> ) <span class="hljs-keyword">begin</span><br>cnt_div6 &lt;= cnt_div6 + <span class="hljs-number">1&#x27;b1</span> ;<span class="hljs-comment">//当cnt_div未计到最大值时 一直自加</span><br>flag_div &lt;= <span class="hljs-number">1&#x27;b0</span>;<span class="hljs-comment">//位选移位信号一直是0</span><br><span class="hljs-keyword">end</span> <br><span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>cnt_div6 &lt;= <span class="hljs-number">31&#x27;b0</span>;<span class="hljs-comment">//当cnt_div计到最大值时 cnt_div6清空</span><br>flag_div &lt;= <span class="hljs-number">1&#x27;b1</span>;<span class="hljs-comment">//位选移位信号置1</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h3 id="数码管显示模块"><a href="#数码管显示模块" class="headerlink" title="数码管显示模块"></a>数码管显示模块</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tube(<br><span class="hljs-keyword">input</span> sys_clk   ,<span class="hljs-comment">//系统输入</span><br><span class="hljs-keyword">input</span> sys_rst_n ,<span class="hljs-comment">//复位</span><br><span class="hljs-keyword">input</span>  add_flag  ,<span class="hljs-comment">//秒自加标志位</span><br><span class="hljs-keyword">input</span>  add_div_flag  ,<span class="hljs-comment">//位移标志位</span><br><span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] dig_sel,<span class="hljs-comment">//位选输出</span><br><span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] dig_data<span class="hljs-comment">//数码管段码输出</span><br>);<br><span class="hljs-keyword">reg</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] num   ;<br><span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] num_0 ;<br><span class="hljs-keyword">reg</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] num_1 ;<br><span class="hljs-keyword">reg</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] num_2 ;<br><br><br><span class="hljs-comment">//12 :36 :50</span><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span> <span class="hljs-comment">//初始化时分秒和数码管位选</span><br>dig_sel &lt;= <span class="hljs-number">6&#x27;b011111</span>;<span class="hljs-comment">//数码管位选</span><br>num_0   &lt;= <span class="hljs-number">4&#x27;d12</span>;<span class="hljs-comment">//时</span><br>num_1   &lt;= <span class="hljs-number">6&#x27;d36</span>;<span class="hljs-comment">//分</span><br>num_2   &lt;= <span class="hljs-number">6&#x27;d50</span>;<span class="hljs-comment">//秒</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> sys_clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> sys_rst_n) <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">if</span>(!sys_rst_n) <span class="hljs-keyword">begin</span><br>dig_sel  &lt;= <span class="hljs-number">6&#x27;b011111</span>;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (add_div_flag == <span class="hljs-number">1&#x27;b1</span>)<span class="hljs-keyword">begin</span><span class="hljs-comment">//移位标志位</span><br>dig_sel[<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] &lt;= &#123;dig_sel[<span class="hljs-number">0</span>],dig_sel[<span class="hljs-number">5</span>:<span class="hljs-number">1</span>]&#125;;<span class="hljs-comment">//移位</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">else</span> <br>dig_sel &lt;= dig_sel ;<span class="hljs-comment">//赋值给自己</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">*时间显示 </span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> sys_clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> sys_rst_n)<span class="hljs-keyword">begin</span><br><span class="hljs-keyword">if</span>(!sys_rst_n) <span class="hljs-keyword">begin</span><span class="hljs-comment">//复位，将时间恢复初始设定</span><br>num_0 &lt;= <span class="hljs-number">12</span>;num_1 &lt;= <span class="hljs-number">36</span>;num_2 &lt;= <span class="hljs-number">50</span>;<span class="hljs-comment">// 12.36.50</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(add_flag == <span class="hljs-number">1&#x27;b1</span>) <span class="hljs-keyword">begin</span><span class="hljs-comment">//当自加标志位为 1 时</span><br>num_2 &lt;= num_2+ <span class="hljs-number">1&#x27;b1</span> ;<span class="hljs-comment">//秒上的值加1</span><br><span class="hljs-keyword">if</span>(num_2 == <span class="hljs-number">6&#x27;d60</span> -<span class="hljs-number">1&#x27;b1</span>) <span class="hljs-keyword">begin</span><span class="hljs-comment">//因为这句判断语句和 上面那句是并行关系 秒为59时进位</span><br>num_2 &lt;= <span class="hljs-number">0</span>;<span class="hljs-comment">//进位后num_2 = 0</span><br>num_1 &lt;= num_1+ <span class="hljs-number">1&#x27;b1</span>;<span class="hljs-comment">//num_1 +1 </span><br><br><span class="hljs-keyword">if</span>(num_1 == <span class="hljs-number">6&#x27;d60</span> -<span class="hljs-number">1&#x27;b1</span>) <span class="hljs-keyword">begin</span><span class="hljs-comment">//因为这句判断语句和 上面那句是并行关系 分为59时进位</span><br>num_1 &lt;= <span class="hljs-number">0</span>;<span class="hljs-comment">//进位后num_1 = 0</span><br>num_0 &lt;= num_0+ <span class="hljs-number">1&#x27;b1</span>;<span class="hljs-comment">//num_0 +1 </span><br><br><span class="hljs-keyword">if</span>(num_0 == <span class="hljs-number">4&#x27;d24</span> -<span class="hljs-number">1&#x27;b1</span>) <span class="hljs-keyword">begin</span><span class="hljs-comment">//因为这句判断语句和 上面那句是并行关系 时为23时进位</span><br>num_0 &lt;= <span class="hljs-number">0</span>;<span class="hljs-comment">//进位后num_0 = 0</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">*根据位选来给num赋值，就是对应的位上的值</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> sys_clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> sys_rst_n) <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">case</span>(dig_sel)<br><span class="hljs-number">6&#x27;b111110</span> :    num &lt;= num_2 % <span class="hljs-number">4&#x27;d10</span>;<br><span class="hljs-number">6&#x27;b111101</span> :    num &lt;= num_2 / <span class="hljs-number">4&#x27;d10</span>;<br><span class="hljs-number">6&#x27;b111011</span> :    num &lt;= num_1 % <span class="hljs-number">4&#x27;d10</span>;<br><span class="hljs-number">6&#x27;b110111</span> :    num &lt;= num_1 / <span class="hljs-number">4&#x27;d10</span>;<br><span class="hljs-number">6&#x27;b101111</span> :    num &lt;= num_0 % <span class="hljs-number">4&#x27;d10</span>;<br><span class="hljs-number">6&#x27;b011111</span> :    num &lt;= num_0 / <span class="hljs-number">4&#x27;d10</span>;<br><span class="hljs-keyword">default</span> : num &lt;= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">endcase</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">*根据需要显示的值转换为数码管的段码</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> sys_clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> sys_rst_n) <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">case</span>(num)<br><span class="hljs-number">4&#x27;h0</span> :    dig_data &lt;= <span class="hljs-number">8&#x27;b1100_0000</span>;<br><span class="hljs-number">4&#x27;h1</span> :    dig_data &lt;= <span class="hljs-number">8&#x27;b1111_1001</span>;<br><span class="hljs-number">4&#x27;h2</span> :    dig_data &lt;= <span class="hljs-number">8&#x27;b1010_0100</span>;<br><span class="hljs-number">4&#x27;h3</span> :    dig_data &lt;= <span class="hljs-number">8&#x27;b1011_0000</span>;<br><span class="hljs-number">4&#x27;h4</span> :    dig_data &lt;= <span class="hljs-number">8&#x27;b1001_1001</span>;<br><span class="hljs-number">4&#x27;h5</span> :    dig_data &lt;= <span class="hljs-number">8&#x27;b1001_0010</span>;<br><span class="hljs-number">4&#x27;h6</span> :    dig_data &lt;= <span class="hljs-number">8&#x27;b1000_0010</span>;<br><span class="hljs-number">4&#x27;h7</span> :    dig_data &lt;= <span class="hljs-number">8&#x27;b1111_1000</span>;<br><span class="hljs-number">4&#x27;h8</span> :    dig_data &lt;= <span class="hljs-number">8&#x27;b1000_0000</span>;<br><span class="hljs-number">4&#x27;h9</span> :    dig_data &lt;= <span class="hljs-number">8&#x27;b1001_0000</span>;<br><span class="hljs-number">4&#x27;ha</span> :    dig_data &lt;= <span class="hljs-number">8&#x27;b1000_1000</span>;<br><span class="hljs-number">4&#x27;hb</span> :    dig_data &lt;= <span class="hljs-number">8&#x27;b1000_0011</span>;<br><span class="hljs-number">4&#x27;hc</span> :    dig_data &lt;= <span class="hljs-number">8&#x27;b1100_0110</span>;<br><span class="hljs-number">4&#x27;hd</span> :    dig_data &lt;= <span class="hljs-number">8&#x27;b1010_0001</span>;<br><span class="hljs-number">4&#x27;he</span> :    dig_data &lt;= <span class="hljs-number">8&#x27;b1000_0110</span>;<br><span class="hljs-number">4&#x27;hf</span> :    dig_data &lt;= <span class="hljs-number">8&#x27;b1000_1110</span>;<br><span class="hljs-keyword">default</span> : dig_data &lt;= <span class="hljs-number">8&#x27;b1100_0000</span>;<br><span class="hljs-keyword">endcase</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br><br><br></code></pre></td></tr></table></figure><h3 id="顶层模块"><a href="#顶层模块" class="headerlink" title="顶层模块"></a>顶层模块</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs awk">module tube_top(<br>input sys_clk,<span class="hljs-regexp">//</span>系统输入<br>input sys_rst_n,<span class="hljs-regexp">//</span>复位输入<br><br>output  [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] dig_sel,<span class="hljs-regexp">//</span>位选数据输出<br>output  [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] dig_data<span class="hljs-regexp">//</span>段选数据输出<br>);<br><br>wire flag ;<br><br>tube tube_inst(<br>.sys_clk     (sys_clk),<span class="hljs-regexp">//</span>系统输入<br>.sys_rst_n   (sys_rst_n),<span class="hljs-regexp">//</span>复位输入<br>.add_flag    (flag),<span class="hljs-regexp">//</span>秒自加标志位输入<br>.add_div_flag(flag_div),<span class="hljs-regexp">//</span>位选位移标志位输入<br>.dig_sel (dig_sel),<span class="hljs-regexp">//</span>位选数据输出<br>.dig_data (dig_data)<span class="hljs-regexp">//</span>段选数据输出<br>);<br><br>cnt cnt_inst(<br>.sys_clk    (sys_clk),<span class="hljs-regexp">//</span>系统输入<br>.sys_rst_n  (sys_rst_n),<span class="hljs-regexp">//</span>复位输入<br>.flag   (flag),<span class="hljs-regexp">//</span>秒自加标志位输出<br>.flag_div   (flag_div)<span class="hljs-regexp">//</span>位选位移标志位输出<br>);<br><br>endmodule<br></code></pre></td></tr></table></figure><h2 id="仿真"><a href="#仿真" class="headerlink" title="仿真"></a>仿真</h2><h3 id="编写测试平台"><a href="#编写测试平台" class="headerlink" title="编写测试平台"></a>编写测试平台</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><br><span class="hljs-meta">`<span class="hljs-keyword">timescale</span> 1ns/1ns</span><br><span class="hljs-keyword">module</span> tb_tube();<br><br><span class="hljs-keyword">reg</span> sys_clk;<span class="hljs-comment">//定义时钟</span><br><span class="hljs-keyword">reg</span> sys_rst_n;<span class="hljs-comment">//定义复位信号</span><br><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]dig_data;<span class="hljs-comment">//定义输出段选信号</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>]dig_sel;<span class="hljs-comment">//定义输出位选信号</span><br><br><span class="hljs-keyword">always</span> #<span class="hljs-number">10</span> sys_clk = ~ sys_clk;<span class="hljs-comment">//模拟晶振</span><br><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>sys_clk = <span class="hljs-number">1&#x27;b1</span> ;<span class="hljs-comment">//初始高电平</span><br>sys_rst_n &lt;= <span class="hljs-number">1&#x27;b0</span>;<span class="hljs-comment">//复位</span><br>#<span class="hljs-number">20</span> sys_rst_n &lt;= <span class="hljs-number">1&#x27;b1</span>;<span class="hljs-comment">//延时将复位信号拉高</span><br><span class="hljs-keyword">end</span><br><br><br>tube_top tube_top_inst(<br><span class="hljs-variable">.sys_clk</span>    (sys_clk),<span class="hljs-comment">//时钟输入</span><br><span class="hljs-variable">.sys_rst_n</span>  (sys_rst_n),<span class="hljs-comment">//复位信号输入</span><br><br><span class="hljs-variable">.dig_sel</span>(dig_sel),<span class="hljs-comment">//输出位选信号</span><br><span class="hljs-variable">.dig_data</span>(dig_data)<span class="hljs-comment">//输出段选信号</span><br>);<br><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p><img src="/img/fpga_demo/tube/0.png"><br><img src="/img/fpga_demo/tube/1.png"></p><h2 id="下载程序"><a href="#下载程序" class="headerlink" title="下载程序"></a>下载程序</h2><h3 id="下载到fpga"><a href="#下载到fpga" class="headerlink" title="下载到fpga"></a>下载到fpga</h3><p>点击图圈位置<br><img src="/img/fpga_demo/tube/2.png"><br>点击start下载</p><h3 id="下载到配置芯片-EPCS64"><a href="#下载到配置芯片-EPCS64" class="headerlink" title="下载到配置芯片 EPCS64"></a>下载到配置芯片 EPCS64</h3><p> .sof 转换成 .jic<br> <img src="/img/fpga_demo/tube/3.png"><br> <img src="/img/fpga_demo/tube/4.png"><br> 点击 add file ,将生成的jic文件添加进来。<br><img src="/img/fpga_demo/tube/5.png"><br> 如果不删除.sof文件下载会出现如下问题<br> <img src="/img/fpga_demo/tube/6.png"><br> 解决办法就是删除.sof文件后再下载。</p><h1 id="iic-驱动eeprom"><a href="#iic-驱动eeprom" class="headerlink" title="iic 驱动eeprom"></a>iic 驱动eeprom</h1><p>AT24C02的内存内部架构是 32页的8byte组成的  32*8byte &#x3D; 256 byte<br><img src="/img/fpga_demo/eeprom/0.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>上网小技巧</title>
    <link href="/2023/01/19/%E4%B8%8A%E7%BD%91%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <url>/2023/01/19/%E4%B8%8A%E7%BD%91%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="学习瓶颈"><a href="#学习瓶颈" class="headerlink" title="学习瓶颈"></a>学习瓶颈</h1><p>平时上github要么就连不上要么就超级慢<br>下载速度简直慢的不行<br>为了加速学习进度<br>这里使用一个开源软件来上网  </p><h1 id="clash"><a href="#clash" class="headerlink" title="clash"></a>clash</h1><p><a href="https://github.com/Fndroid/clash_for_windows_pkg/releases/">clash</a><br>下载 <font color ="dd0000">Clash.for.Windows-0.20.12-x64-linux.tar.gz</font><br><img src="/img/getnet/0.png"><br>下载完成后解压<br><img src="/img/getnet/1.png"><br>这样就行</p><h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./cfw<br></code></pre></td></tr></table></figure><p>将绿色按钮位置的两个都打开<br><img src="/img/getnet/2.png"><br>Mixin 开启服务<br>Start with Linux 是开机自启</p><h1 id="服务商"><a href="#服务商" class="headerlink" title="服务商"></a>服务商</h1><p><a href="https://suyunti.com/auth/register?code=aQSB">net</a><br>注册登录<br><img src="/img/getnet/3.png"><br>16块一个月也挺便宜不看电影100G完全够用了  </p><h1 id="导入配置文件"><a href="#导入配置文件" class="headerlink" title="导入配置文件"></a>导入配置文件</h1><p>可以是一键导入也可以是复制链接<br><img src="/img/getnet/4.png">  </p><h1 id="手动配置本地"><a href="#手动配置本地" class="headerlink" title="手动配置本地"></a>手动配置本地</h1><p><img src="/img/getnet/5.png">  </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo+gitee</title>
    <link href="/2023/01/07/hexo-gitee/"/>
    <url>/2023/01/07/hexo-gitee/</url>
    
    <content type="html"><![CDATA[<h1 id="ubuntu安装"><a href="#ubuntu安装" class="headerlink" title="ubuntu安装"></a>ubuntu安装</h1><p>安装git  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install git-core<br></code></pre></td></tr></table></figure><p>安装依赖  </p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo snap <span class="hljs-keyword">install</span> curl<br></code></pre></td></tr></table></figure><p>添加nodejs源  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -fsSL https:<span class="hljs-regexp">//</span>deb.nodesource.c om/setup_19.x | sudo -E bash -<br></code></pre></td></tr></table></figure><p><a href="https://github.com/nodesource/distributions/blob/459b42923bb637b4b9b4728376e2e04d6f5a370f/README.md">官方 readme</a><br>安装nodejs  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install -y nodejs<br></code></pre></td></tr></table></figure><p>安装hexo  </p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><p>检查nodejs安装版本  </p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">-v</span> <br></code></pre></td></tr></table></figure><p><img src="/img/hexo+gitee/0.png"><br>检查npm安装版本  </p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> -v<br></code></pre></td></tr></table></figure><p><img src="/img/hexo+gitee/1.png"><br>检查hexo版本  </p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo -v</span><br></code></pre></td></tr></table></figure><p><img src="/img/hexo+gitee/2.png"></p><h1 id="设置-git"><a href="#设置-git" class="headerlink" title="设置 git"></a>设置 git</h1><p>配置账户邮箱  </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-number">2556892336</span>@qq<span class="hljs-selector-class">.com</span> <br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&#x27;huerli&#x27;</span><br></code></pre></td></tr></table></figure><p>查看账户邮箱  </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global user.name</span><br>git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global user.email</span><br></code></pre></td></tr></table></figure><p><img src="/img/hexo+gitee/3.png"><br>本地生成ssh公钥  </p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">&quot;2556892336@qq.com&quot;</span><br></code></pre></td></tr></table></figure><p>回车三次结果如图<br><img src="/img/hexo+gitee/4.png"><br>查看设置的密钥将隐藏文件打开<br><img src="/img/hexo+gitee/5.png"><br>查看公钥(id_rsa.pub)用文本编辑器打开<br><img src="/img/hexo+gitee/6.png"><br>打开gitee设置<br>点击SSH公钥<br><img src="/img/hexo+gitee/7.png"><br>添加后确认<br>验证密码<br><img src="/img/hexo+gitee/8.png"><br>正确后显示成功<br><img src="/img/hexo+gitee/9.png"></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> -T git<span class="hljs-variable">@gitee</span>.com<br></code></pre></td></tr></table></figure><p>输入 yes<br><img src="/img/hexo+gitee/10.png"><br>成功显示<br><img src="/img/hexo+gitee/11.png"></p><h1 id="Blog部分"><a href="#Blog部分" class="headerlink" title="Blog部分"></a>Blog部分</h1><p>创建blog文件夹  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> blog &amp;&amp; <span class="hljs-built_in">cd</span> blog <br></code></pre></td></tr></table></figure><p>初始化blog文件夹<br>建议使用手机热点，不然有点慢  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">hexo <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure><p>启动 hexo(在博客目录下)</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">hexo</span> g<span class="hljs-comment"># 生成静态网页</span><br>hexo s<span class="hljs-comment"># 启动服务</span><br></code></pre></td></tr></table></figure><p>浏览器访问 <a href="http://localhost:4000/">http://localhost:4000</a></p><h1 id="创建gitee仓库"><a href="#创建gitee仓库" class="headerlink" title="创建gitee仓库"></a>创建gitee仓库</h1><p>如图所示即可<br><img src="/img/hexo+gitee/12.png"></p><h1 id="上传gitee"><a href="#上传gitee" class="headerlink" title="上传gitee"></a>上传gitee</h1><p>编辑 _config.yml  </p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repository:</span> https:<span class="hljs-comment">//gitee.com/huerli/huerli.git</span><br><span class="hljs-symbol">  branch:</span> master<br></code></pre></td></tr></table></figure><p>上传  </p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g</span><br><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure><p>需要输入gitee帐号密码<br><img src="/img/hexo+gitee/13.png"><br>出现<font color ="dd0000">deploy done git</font>就是成功<br><img src="/img/hexo+gitee/14.png"></p><h1 id="开始-page-服务"><a href="#开始-page-服务" class="headerlink" title="开始 page 服务"></a>开始 page 服务</h1><p>点击page服务第一次需要实名，完成后就可以开启了<br><img src="/img/hexo+gitee/15.png"><br>每次上传都需要更新<br><img src="/img/hexo+gitee/16.png"></p><h1 id="善后工作（删除）"><a href="#善后工作（删除）" class="headerlink" title="善后工作（删除）"></a>善后工作（删除）</h1><p>什么！你不要了？装错了？删除重来？<br>ok<br><del>sudo rm -rf</del>(bushi  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> <span class="hljs-built_in">remove</span> nodejs<br></code></pre></td></tr></table></figure><p>將源删除</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo rm <span class="hljs-regexp">/etc/</span>apt<span class="hljs-regexp">/sources.list.d/</span>nodesource.list<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu操作集合</title>
    <link href="/2023/01/07/ubuntu%E6%93%8D%E4%BD%9C%E9%9B%86%E5%90%88/"/>
    <url>/2023/01/07/ubuntu%E6%93%8D%E4%BD%9C%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="安装拼音输入法"><a href="#安装拼音输入法" class="headerlink" title="安装拼音输入法"></a>安装拼音输入法</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install ibus-pinyin<br></code></pre></td></tr></table></figure><p>点击加号<br><img src="/img/ubuntu-operation/0.png"><br>点击other<br><img src="/img/ubuntu-operation/1.png"><br>输入 chinese<br><img src="/img/ubuntu-operation/2.png"><br>使用 win+space 切换<br>可以在键盘快捷键处改变快捷键  </p><h1 id="安装ADB"><a href="#安装ADB" class="headerlink" title="安装ADB"></a>安装ADB</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install android-tools-adb<br></code></pre></td></tr></table></figure><p>编写规则</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo gedit <span class="hljs-regexp">/etc/u</span>dev<span class="hljs-regexp">/rules.d/</span><span class="hljs-number">80</span>-android.rules<br></code></pre></td></tr></table></figure><p>写入(其中红色字体部分需要 lsusb 查看)<br>SUBSYSTEM&#x3D;&#x3D;”usb”, ATTRS{idVendor}&#x3D;&#x3D;”<font color ="dd0000"> 18d1 </font>“, ATTRS{idProduct}&#x3D;&#x3D;”<font color ="dd0000"> d002 </font>“,MODE&#x3D;”0666”</p><h1 id="nfs服务-ubuntu"><a href="#nfs服务-ubuntu" class="headerlink" title="nfs服务 ubuntu"></a>nfs服务 ubuntu</h1><p>安装  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">sudo apt-<span class="hljs-keyword">get</span> install nfs-kernel-<span class="hljs-keyword">server</span> rpcbind -y<br></code></pre></td></tr></table></figure><p>打开 nfs 配置文件&#x2F;etc&#x2F;exports  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo gedit <span class="hljs-regexp">/etc/</span>exports<br></code></pre></td></tr></table></figure><p>写入配置（对应nfs路径）  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/home/</span>huerli<span class="hljs-regexp">/linux/</span>nfs *(rw,sync,no_root_squash)<br></code></pre></td></tr></table></figure><p>写入如图所示<br><img src="/img/ubuntu-operation/3.png"><br>重启 NFS 服务，使用命令如下：  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo <span class="hljs-regexp">/etc/i</span>nit.d/nfs-kernel-server restart<br></code></pre></td></tr></table></figure><p>网络挂载rootfs出现错误<br><img src="/img/ubuntu-operation/nfs_0.png"><br>打开 &#x2F;etc&#x2F;default&#x2F;nfs-kernel-server  </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">sudo gedit <span class="hljs-regexp">/etc/</span><span class="hljs-keyword">default</span>/nfs-kernel-server<br></code></pre></td></tr></table></figure><p>输入如下</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">RPCNFSDOPTS</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;--nfs-version 2,3,4 --debug --syslog&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/img/ubuntu-operation/nfs_1.png"><br>重启服务  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo <span class="hljs-regexp">/etc/i</span>nit.d/nfs-kernel-server restart<br></code></pre></td></tr></table></figure><h1 id="ssh服务"><a href="#ssh服务" class="headerlink" title="ssh服务"></a>ssh服务</h1><h2 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h2><p>安装即可  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">sudo apt-<span class="hljs-keyword">get</span> install openssh-<span class="hljs-keyword">server</span> -y<br></code></pre></td></tr></table></figure><h2 id="buildroot构建的根文件系统"><a href="#buildroot构建的根文件系统" class="headerlink" title="buildroot构建的根文件系统"></a>buildroot构建的根文件系统</h2><p>buildroot勾选编译openssh</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">-&gt; Target packages <br>-&gt; Networking applications<br>-&gt; [*] openssh <span class="hljs-comment">//使能 openssh</span><br></code></pre></td></tr></table></figure><p><img src="/img/ubuntu-operation/ssh_0.png"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>创建用户<br>adduser huerli<br>输入两次密码<br>给权限  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">chown root:root <span class="hljs-regexp">/var/</span>empty<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">PermitRootLogin <span class="hljs-built_in">yes</span><br>AuthorizedKeysFile.ssh/authorized_keys<br></code></pre></td></tr></table></figure><h1 id="固定设备IP"><a href="#固定设备IP" class="headerlink" title="固定设备IP"></a>固定设备IP</h1><p><img src="/img/ubuntu-operation/4.png"></p><h1 id="ftp服务器"><a href="#ftp服务器" class="headerlink" title="ftp服务器"></a>ftp服务器</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo apt-get install vsftpd &amp;&amp; sudo gedit <span class="hljs-regexp">/etc/</span>vsftpd.conf <br></code></pre></td></tr></table></figure><p>把以下两个值前方的 # 取消</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">local_enable</span>=<span class="hljs-literal">YES</span><br><span class="hljs-attr">write_enable</span>=<span class="hljs-literal">YES</span><br></code></pre></td></tr></table></figure><p>重启服务  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo <span class="hljs-regexp">/etc/i</span>nit.d/vsftpd restart<br></code></pre></td></tr></table></figure><h1 id="tftp服务ubuntu"><a href="#tftp服务ubuntu" class="headerlink" title="tftp服务ubuntu"></a>tftp服务ubuntu</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install tftp-hpa tftpd-hpa xinetd<br></code></pre></td></tr></table></figure><p>创建文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo mkdir <span class="hljs-regexp">/etc/</span>xinetd.d &amp;&amp; sudo gedit <span class="hljs-regexp">/etc/</span>xinetd.d/tftp<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs abnf">server tftp<br>&#123;<br>socket_type <span class="hljs-operator">=</span> dgram<br>protocol <span class="hljs-operator">=</span> udp<br>wait <span class="hljs-operator">=</span> yes<br>user <span class="hljs-operator">=</span> root<br>server <span class="hljs-operator">=</span> /usr/sbin/in.tftpd<br>server_args <span class="hljs-operator">=</span> -s /home/huerli/linux/tftpboot/<br>disable <span class="hljs-operator">=</span> no<br>per_source <span class="hljs-operator">=</span> <span class="hljs-number">11</span><br>cps <span class="hljs-operator">=</span> <span class="hljs-number">100</span> <span class="hljs-number">2</span><br>flags <span class="hljs-operator">=</span> IPv4<br>&#125;<br></code></pre></td></tr></table></figure><p>启动 tftp 服务</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">sudo service tftpd-hpa <span class="hljs-literal">start</span><br></code></pre></td></tr></table></figure><p>打开&#x2F;etc&#x2F;default&#x2F;tftpd-hpa 文件</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">sudo gedit <span class="hljs-regexp">/etc/</span><span class="hljs-keyword">default</span>/tftpd-hpa<br></code></pre></td></tr></table></figure><p>修改为如下</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># /etc/default/tftpd-hpa</span><br><br><span class="hljs-attr">TFTP_USERNAME</span>=<span class="hljs-string">&quot;tftp&quot;</span><br><span class="hljs-attr">TFTP_DIRECTORY</span>=<span class="hljs-string">&quot;/home/huerli/linux/tftpboot&quot;</span><br><span class="hljs-attr">TFTP_ADDRESS</span>=<span class="hljs-string">&quot;:69&quot;</span><br><span class="hljs-attr">TFTP_OPTIONS</span>=<span class="hljs-string">&quot;-l -c -s&quot;</span><br></code></pre></td></tr></table></figure><p>重启服务器</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo service tftpd-hpa restart</span><br></code></pre></td></tr></table></figure><p>启动开发板<br><img src="/img/ubuntu-operation/5.png"></p><h1 id="vscode-开发"><a href="#vscode-开发" class="headerlink" title="vscode 开发"></a>vscode 开发</h1><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">C</span><span class="hljs-operator">/</span><span class="hljs-built_in">C</span><span class="hljs-operator">++</span>  <br><span class="hljs-built_in">C</span><span class="hljs-operator">/</span><span class="hljs-built_in">C</span><span class="hljs-operator">++</span> <span class="hljs-variable">Snippets</span>  <br><span class="hljs-built_in">C</span><span class="hljs-operator">/</span><span class="hljs-built_in">C</span><span class="hljs-operator">++</span> <span class="hljs-variable">Advanced</span> <span class="hljs-variable">Lint</span>  <br><span class="hljs-variable">Code</span> <span class="hljs-variable">Runner</span>  <br><span class="hljs-variable">Include</span> <span class="hljs-variable">AutoComplete</span>  <br><span class="hljs-variable">Rainbow</span> <span class="hljs-variable">Brackets</span>  <br><span class="hljs-variable">One</span> <span class="hljs-variable">Dark</span> <span class="hljs-variable">Pro</span>  <br><span class="hljs-variable">GBKtoUTF8</span>  <br><span class="hljs-variable">ARM</span>  <br><span class="hljs-variable">vscode</span><span class="hljs-operator">-</span><span class="hljs-variable">icons</span>  <br><span class="hljs-variable">compareit</span>  <br><span class="hljs-variable">DeviceTree</span>  <br><span class="hljs-variable">TabNine</span>  <br><span class="hljs-variable">Chinese</span><span class="hljs-punctuation">(</span><span class="hljs-variable">Simplified</span><span class="hljs-punctuation">)</span>  <br></code></pre></td></tr></table></figure><p>设置中文 ctrl+shift+p<br>输入 选择中文</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">configure language</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tina-lcd</title>
    <link href="/2023/01/05/tina-lcd/"/>
    <url>/2023/01/05/tina-lcd/</url>
    
    <content type="html"><![CDATA[<h1 id="打开LCD显示"><a href="#打开LCD显示" class="headerlink" title="打开LCD显示"></a>打开LCD显示</h1><p>在tina-linux 的sdk中lcd显示是默认打开的，所以不需要作过多的操作，但是设备树中屏幕的分辨率参数等等可能和你使用的屏幕不一样，所以需要修改一下。  </p><h2 id="修改设备树"><a href="#修改设备树" class="headerlink" title="修改设备树"></a>修改设备树</h2><p>设备树位置  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">device<span class="hljs-regexp">/config/</span>chips<span class="hljs-regexp">/(你的芯片)/</span>configs<span class="hljs-regexp">/mq_r/</span>board.dts<br></code></pre></td></tr></table></figure><p>打开后ctrl+f 搜索 ‘lcd0’，找未被注释的lcd0  </p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">&amp;lcd0 &#123;<br>lcd_used            = <span class="hljs-variable">&lt;1&gt;</span>;<br><br>lcd_driver_name     = <span class="hljs-string">&quot;default_lcd&quot;</span>;<br>lcd_if              = <span class="hljs-variable">&lt;0&gt;</span>;<br>lcd_x               = <span class="hljs-variable">&lt;800&gt;</span>;<br>lcd_y               = <span class="hljs-variable">&lt;480&gt;</span>;<br>lcd_width           = <span class="hljs-variable">&lt;150&gt;</span>;<br>lcd_height          = <span class="hljs-variable">&lt;94&gt;</span>;<br>lcd_dclk_freq       = <span class="hljs-variable">&lt;48&gt;</span>;<br>......<br></code></pre></td></tr></table></figure><p>大概就是这些内容，需要修改的就是lcd_x,lcd_y修改为对应的。<br>将修改为的设备树重新编译并烧录<br>进行雪花屏测试  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/dev/u</span>random &gt; <span class="hljs-regexp">/dev/</span>fb0<br></code></pre></td></tr></table></figure><p>清屏</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/dev/</span>zero &gt; <span class="hljs-regexp">/dev/</span>fb0<br></code></pre></td></tr></table></figure><p>彩屏测试</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">echo <span class="hljs-number">8</span> &gt; <span class="hljs-regexp">/sys/</span><span class="hljs-keyword">class</span><span class="hljs-regexp">/disp/</span>disp<span class="hljs-regexp">/attr/</span>colorbar<br></code></pre></td></tr></table></figure><h1 id="gt911触摸"><a href="#gt911触摸" class="headerlink" title="gt911触摸"></a>gt911触摸</h1><p>设备树存在也可以正常驱动触摸屏<br>将gt911驱动编译进内核  </p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">source</span> build/envsetup.<span class="hljs-keyword">sh</span>&amp;&amp;lunch&amp;&amp;<span class="hljs-keyword">make</span> kernel_menuconfig<br></code></pre></td></tr></table></figure><p>选择对应芯片<br><img src="/img/tina-linux-lcd/0.png"><br>驱动路径</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xl">D<span class="hljs-function"><span class="hljs-title">evice</span> Drivers  ---&gt;</span> <br>I<span class="hljs-function"><span class="hljs-title">nput</span> device support  ---&gt;</span><br>[*]   T<span class="hljs-function"><span class="hljs-title">ouchscreens</span>  ---&gt;</span><br>&lt;*&gt;   Goodix I2C touchscreen<br>&lt;*&gt;   gt9xxnew touchscreen driver<br><br></code></pre></td></tr></table></figure><p>勾选tslib库测试屏幕</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">make menuconfig</span><br></code></pre></td></tr></table></figure><p>库路径</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xl">L<span class="hljs-function"><span class="hljs-title">ibraries</span>  ---&gt;</span> <br>&lt;*&gt;tslib<br>A<span class="hljs-function"><span class="hljs-title">llwinner</span>  ---&gt;</span><br>&lt;*&gt;mtop<br></code></pre></td></tr></table></figure><p>编译烧录  </p><p>查看设备节点  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">ls <span class="hljs-regexp">/dev/i</span>nput/<br></code></pre></td></tr></table></figure><p>可以看到对应的设备节点</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">eve<span class="hljs-symbol">nt0</span>  eve<span class="hljs-symbol">nt1</span><br></code></pre></td></tr></table></figure><h1 id="little-lvgl-示例"><a href="#little-lvgl-示例" class="headerlink" title="little lvgl 示例"></a>little lvgl 示例</h1><h2 id="使能例程"><a href="#使能例程" class="headerlink" title="使能例程"></a>使能例程</h2><p>官方默认也使能了lvgl的例程</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">make menuconfig</span><br></code></pre></td></tr></table></figure><p>自行勾选需要的例程</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">Gui <span class="hljs-comment">---&gt;</span><br>Liitevgl <span class="hljs-comment">---&gt;</span><br>&lt;*&gt; lv_examples<br>&lt;*&gt; lvgl-<span class="hljs-number">8.1</span>.<span class="hljs-number">0</span> <span class="hljs-keyword">use</span> sunxifb double <span class="hljs-keyword">buffer</span><br>&lt;*&gt; lvgl-<span class="hljs-number">8.1</span>.<span class="hljs-number">0</span> <span class="hljs-keyword">use</span> sunxifb cache<br>-*- lvgl-<span class="hljs-number">8.1</span>.<span class="hljs-number">0</span> <span class="hljs-keyword">use</span> sunxifb g2d<br>&lt;*&gt; lvgl-<span class="hljs-number">8.1</span>.<span class="hljs-number">0</span> <span class="hljs-keyword">use</span> sunxifb g2d rotate<br>&lt;*&gt; lv_g2d_test<br>&lt;*&gt; lv_monitor<br></code></pre></td></tr></table></figure><p>编译烧录<br>在终端中输入  </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">lv_examples</span> <span class="hljs-number">0</span> or <span class="hljs-number">1</span> or <span class="hljs-number">2</span> or <span class="hljs-number">3</span> or <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>可以看到对应的例程现象，同时也看到了报错<br><img src="/img/tina-linux-lcd/1.png"><br>这个报错是应为触摸对应的节点没有和源码对上(lv_drv_conf.h)<br><img src="/img/tina-linux-lcd/2.png"><br>源码中节点是 <font color ="dd0000" size = 13> event3 </font><br>在终端做一个文件映射（比如你的触摸设备是event1） </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">ln -s <span class="hljs-regexp">/dev/i</span>nput<span class="hljs-regexp">/event1 /</span>dev<span class="hljs-regexp">/input/</span>event3 <br></code></pre></td></tr></table></figure><p>或者是将源码修改为触摸设备对应的节点  </p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tina</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tina-linux-wifi</title>
    <link href="/2023/01/03/tina-linux-wifi/"/>
    <url>/2023/01/03/tina-linux-wifi/</url>
    
    <content type="html"><![CDATA[<h1 id="tina-linux初体验"><a href="#tina-linux初体验" class="headerlink" title="tina-linux初体验"></a>tina-linux初体验</h1><p>编译tina就是一个巨坑这一步是最难的，建议就是同百度网盘来下载文件。官方网站真的真的真的太慢了…<br>成功搭建编译环境之后，直接进行编译，编译出的结果镜像却无法连接wifi！<br>输入官方提供的wifi指令却显示报错<br><img src="/img/tina-linux-wifi/0.png"><br>出现这个错误我们从<font color ="00ff00" size = 10>三个方面</font>来看这个问题<br>1.驱动<br>查看驱动命令检查驱动是否在运行并且是不是对应网卡的驱动</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>lsmod <br></code></pre></td></tr></table></figure><p><img src="/img/tina-linux-wifi/1.png"><br>我的板子是T113,对应的网卡驱动是8723DS并不是8189fs，所以需要将这个驱动卸载。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>rmmod <span class="hljs-number">8189</span>fs<br></code></pre></td></tr></table></figure><p>出现图上内容则卸载驱动成功<br><img src="/img/tina-linux-wifi/2.png"><br>加载正确的wifi驱动</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>modprobe <span class="hljs-number">8723</span>ds.ko<br></code></pre></td></tr></table></figure><p><img src="/img/tina-linux-wifi/3.png"><br>出现图上内容则加载驱动成功<br>2.网卡<br>检查网卡是否在工作</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>ifconfig<br></code></pre></td></tr></table></figure><p><img src="/img/tina-linux-wifi/4.png"><br>出现图上内容则网卡在工作<br>3.wap服务<br>在进程中查看wpa_supplicant是否存在  </p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">ps</span> | grep wpa_supplicant<br></code></pre></td></tr></table></figure><p>出现的是下方内容则说明该进程不存在<br><img src="/img/tina-linux-wifi/5.png"></p><p>输入该命令启动服务  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ <span class="hljs-regexp">/etc/i</span>nit.d/wpa_supplicant start<br></code></pre></td></tr></table></figure><p>出现的是下方内容则说明该进程存在<br><img src="/img/tina-linux-wifi/6.png"><br>尝试连接wifi  </p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>wifi_connect_ap_test DAP <span class="hljs-number">12345678</span><br></code></pre></td></tr></table></figure><p><img src="/img/tina-linux-wifi/7.png"><br>wifi连接成功<br>尝试ping外网<br><img src="/img/tina-linux-wifi/8.png"><br>能ping通百度</p><h1 id="开机自启动驱动和服务"><a href="#开机自启动驱动和服务" class="headerlink" title="开机自启动驱动和服务"></a>开机自启动驱动和服务</h1><p>开机自启动的程序一般是存放在 <font color ="dddd00" size = 10>&#x2F;etc&#x2F;init.d </font> 下<br>使用下方指令查看自启动文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ vi <span class="hljs-regexp">/etc/i</span>nit.d/rsC <br></code></pre></td></tr></table></figure><p>可以看到自启动模块驱动文件是 &#x2F;etc&#x2F;init.d&#x2F;rc.moudles<br><img src="/img/tina-linux-wifi/9.png"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ vi <span class="hljs-regexp">/etc/i</span>nit.d/rc.moudles <br></code></pre></td></tr></table></figure><p>驱动8723ds被注释了，将#删除 并将用不到的驱动注释<br><img src="/img/tina-linux-wifi/10.png"><br>注释后如下：<br><img src="/img/tina-linux-wifi/11.png"></p><hr><p>查看 &#x2F;etc&#x2F;profile 可以看到如下的语句 它会执行&#x2F;etc&#x2F;profile.d 所有以 .sh结尾的文件<br><img src="/img/tina-linux-wifi/12.png"><br>看看 &#x2F;etc&#x2F;profile.d 是否存在 若不存在则创建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> /etc/profile.d</span><br></code></pre></td></tr></table></figure><p>传建启动文件</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ <span class="hljs-keyword">vi</span> wifi_connect.<span class="hljs-keyword">sh</span><br></code></pre></td></tr></table></figure><p>写入</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">wifi_connect_ap_test</span> DAP <span class="hljs-number">12345678</span><br></code></pre></td></tr></table></figure><p>重新启动后可以看到有连接信息打印<br><img src="/img/tina-linux-wifi/13.png"></p><h1 id="一劳永逸-修改源码中的内容"><a href="#一劳永逸-修改源码中的内容" class="headerlink" title="一劳永逸:修改源码中的内容"></a>一劳永逸:修改源码中的内容</h1><p>位置</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">target<span class="hljs-regexp">/allwinner/</span>(芯片平台)<span class="hljs-regexp">/busybox-init-base-files/</span>etc<br></code></pre></td></tr></table></figure><p><img src="/img/tina-linux-wifi/14.png"><br>修改ssid和psk 分别是WIFI名称和密码<br><img src="/img/tina-linux-wifi/15.png"></p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tina</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32+esp8266接入云</title>
    <link href="/2022/12/31/stm32-esp8266%E6%8E%A5%E5%85%A5%E4%BA%91/"/>
    <url>/2022/12/31/stm32-esp8266%E6%8E%A5%E5%85%A5%E4%BA%91/</url>
    
    <content type="html"><![CDATA[<h1 id="云部分"><a href="#云部分" class="headerlink" title="云部分"></a>云部分</h1><h2 id="新建阿里云产品和设备"><a href="#新建阿里云产品和设备" class="headerlink" title="新建阿里云产品和设备"></a>新建阿里云产品和设备</h2><p><img src="/img/stm32+esp8266/0.png"><br>点击创建产品<br><img src="/img/stm32+esp8266/1.png"><br>点击添加设备<br><img src="/img/stm32+esp8266/2.png"><br><img src="/img/stm32+esp8266/3.png"><br>devicename 可以随便写。<br><img src="/img/stm32+esp8266/4.png"></p><h2 id="ESP8266"><a href="#ESP8266" class="headerlink" title="ESP8266"></a>ESP8266</h2><h3 id="ESP8266-MQTT固件烧录"><a href="#ESP8266-MQTT固件烧录" class="headerlink" title="ESP8266 MQTT固件烧录"></a>ESP8266 MQTT固件烧录</h3><p>MQTT AT 固件链接<a href="https://pan.baidu.com/s/10xE-DGubCJ7KQlC-Vop08g">baiduyun</a> 提取码 1ztn<br>准备一个ESP8266 01S 和一个烧写器（会方便很多，不然总是烧写失败）<br><img src="/img/stm32+esp8266/5.png"><br><img src="/img/stm32+esp8266/6.png"><br>打开烧写工具<br><img src="/img/stm32+esp8266/7.png"><br>选择箭头所指<br><img src="/img/stm32+esp8266/8.png"><br>跟着箭头设置<br><img src="/img/stm32+esp8266/9.png"><br>烧录完成后<br>将ESP8266拔下重新上电。通过串口助手打开，就会有信息发送。 波特率默认是115200.<br><img src="/img/stm32+esp8266/10.png"><br><font color ="ff00ff">发送一个AT需要勾选发送新行。</font>  可以和我一样将命令保存在串口助手的多条发送上<br><img src="/img/stm32+esp8266/11.png"></p><h2 id="获取mqtt设备连接阿里云的参数"><a href="#获取mqtt设备连接阿里云的参数" class="headerlink" title="获取mqtt设备连接阿里云的参数"></a>获取mqtt设备连接阿里云的参数</h2><h3 id="获取三要素"><a href="#获取三要素" class="headerlink" title="获取三要素"></a>获取三要素</h3><p>在产品界面选择你的产品，进入后选择设备，进入设备界面后通过箭头 2 查看链接三要数。<br><img src="/img/stm32+esp8266/12.png"><br>一键复制出来，可以先粘贴到记事本，方便一会查看<br><img src="/img/stm32+esp8266/13.png"></p><h3 id="重新配置加密参数"><a href="#重新配置加密参数" class="headerlink" title="重新配置加密参数"></a>重新配置加密参数</h3><p>首先将三元组粘贴在右边的框框里，然后在箭头②处随便输入五个字符。点击右下角的生成就会生成链接参数。<br><img src="/img/stm32+esp8266/14.png"></p><h3 id="MQTT-AT-链接阿里云指令"><a href="#MQTT-AT-链接阿里云指令" class="headerlink" title="MQTT AT 链接阿里云指令"></a>MQTT AT 链接阿里云指令</h3><p>官方文档：<a href="https://docs.espressif.com/projects/esp-at/zh_CN/latest/esp32/AT_Command_Set/MQTT_AT_Commands.html">docs</a><br>通过AT 指令链接上阿里云的指令如下。  </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">AT</span>+CIPSNTPCFG=<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-string">&quot;ntp1.aliyun.com&quot;</span><br><span class="hljs-attribute">AT</span>+MQTTUSERCFG=<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;NULL&quot;</span>,<span class="hljs-string">&quot;USERNAME&quot;</span>,<span class="hljs-string">&quot;PASSWARD&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&quot;&quot;</span><br><span class="hljs-attribute">AT</span>+MQTTCLIENTID=<span class="hljs-number">0</span>,<span class="hljs-string">&quot;Clientid&quot;</span><br><span class="hljs-attribute">AT</span>+MQTTCONN=<span class="hljs-number">0</span>,<span class="hljs-string">&quot;链接域名&quot;</span>,链接端口,<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>需要注意的是CLIENTID里的参数需要添加转义字符，例如：  </p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">AT</span>+MQTTCLIENTID=<span class="hljs-number">0</span>,<span class="hljs-string">&quot;12345|securemode=3\,signmethod=hmacsha1|&quot;</span><br></code></pre></td></tr></table></figure><p>链接域名复制到  .com为止，链接端口填 1883<br><img src="/img/stm32+esp8266/15.png"></p><h3 id="MQTT订阅和上报参数的-AT-指令"><a href="#MQTT订阅和上报参数的-AT-指令" class="headerlink" title="MQTT订阅和上报参数的 AT 指令"></a>MQTT订阅和上报参数的 AT 指令</h3><p>我们可以在产品界面的Topic列表的物模通信Topic看到具有<font color = "ff0000">发布</font> 和<font color = "ff0000">订阅</font>的Topic。<br><img src="/img/stm32+esp8266/16.png"><br>我们可以在自定义的Topic中选择一个具有订阅权限的Topic<br><img src="/img/stm32+esp8266/17.png"><br>通过串口助手订阅主题，将decicename替换成自己的设备名称。  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">Topic <span class="hljs-regexp">/hq42unqMiBQ/</span><span class="hljs-variable">$&#123;deviceName&#125;</span><span class="hljs-regexp">/user/g</span>et<br>AT+MQTTSUB=<span class="hljs-number">0</span>,<span class="hljs-string">&quot;/hq42unqMiBQ/test/user/get&quot;</span>,<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>订阅成功后在设备的Topic列表会出现一个已订阅的Topic。<br><img src="/img/stm32+esp8266/18.png"><br>我们可以点击发布消息，测试一下esp8266是否能够成功的收到云端发布的消息。<br><img src="/img/stm32+esp8266/19.png"><br>在串口助手可以看到我们接收到的消息。说明订阅成功。<br><img src="/img/stm32+esp8266/20.png"><br>订阅一个Topic也是同样的道理。<br>第一个引号里面是Topic，第二个引号里面是想要发送的消息  </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">AT</span>+MQTTPUB=<span class="hljs-number">0</span>,<span class="hljs-string">&quot;/hq42unqMiBQ/test/user/get&quot;</span>,<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>通过串口助手发送消息，发送成功会返回一个OK。<br><img src="/img/stm32+esp8266/21.png"><br>同时我们可以在监控运维的日志服务中选择我们的产品进行查看消息。<br><img src="/img/stm32+esp8266/22.png"><br>点击查看。就可以看到我们向云端发送的消息。<br><img src="/img/stm32+esp8266/23.png"></p><h1 id="STM32部分"><a href="#STM32部分" class="headerlink" title="STM32部分"></a>STM32部分</h1><h2 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h2><p><img src="/img/stm32+esp8266/24.png"><br><img src="/img/stm32+esp8266/25.png"><br>打开串口1的异步通讯，作为打印的数据串口。<br><img src="/img/stm32+esp8266/26.png"><br>打开串口2的异步通讯，作为ESP8266通讯的串口。<br><img src="/img/stm32+esp8266/27.png"><br>将频率修改为72M<br><img src="/img/stm32+esp8266/28.png"><br>LCD配置：<a href="https://blog.csdn.net/huuuerli/article/details/125576184?spm=1001.2014.3001.5501">csdn</a><br>创建工程<br><img src="/img/stm32+esp8266/29.png"><br><img src="/img/stm32+esp8266/30.png"></p><h2 id="添加源文件"><a href="#添加源文件" class="headerlink" title="添加源文件"></a>添加源文件</h2><p>源文件链接<a href="https://pan.baidu.com/s/1iMf45oi4QBp2OQcmAYmzoQ">baiduyun</a> 提取码：6a3i<br>加入工程<br><img src="/img/stm32+esp8266/31.png"><br>添加文件路径。<br><img src="/img/stm32+esp8266/32.png"><br><img src="/img/stm32+esp8266/33.png"><br><img src="/img/stm32+esp8266/34.png"><br><img src="/img/stm32+esp8266/35.png"></p><h2 id="修改esp8266-h"><a href="#修改esp8266-h" class="headerlink" title="修改esp8266.h"></a>修改esp8266.h</h2><p>需要修改的部分已经通过箭头指出，在这些宏定义中<font color = "ff0000">转意符 “\”</font> 不可以随意删除，会导致指令发送失败。<br><img src="/img/stm32+esp8266/36.png"></p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>在初始化位置添加初始化函数。初始化函数在esp8266.c中可自行查看。  </p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">HAL_UART_Receive_IT</span>(&amp;huart2, (uint8_t *)&amp;a_esp8266_buf, <span class="hljs-number">1</span>);<br><span class="hljs-built_in">LCD_Init</span>(); #使用则加不使用则不加<br><span class="hljs-built_in">ESP8266_Init_ALIYUN</span>();<br></code></pre></td></tr></table></figure><p>需要勾选MicroLIB的库，否则printf不可使用，会导致LCD_Init 函数卡死。 <br><img src="/img/stm32+esp8266/37.png"><br>同时在USART.C的如下位置添加如下代码，进行串口重定向。 <br><img src="/img/stm32+esp8266/38.png"></p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __GNUC__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PUTCHAR_PROTOTYPE int __io_putchar(int ch)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-title class_">PUTCHAR_PROTOTYPE</span><br><span class="hljs-punctuation">&#123;</span><br>HAL_UART_Transmit(<span class="hljs-variable">&amp;huart1</span>, (uint8_t *)<span class="hljs-variable">&amp;ch</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0xFFFF</span>)<span class="hljs-punctuation">;</span><br>return <span class="hljs-attr">ch</span><span class="hljs-punctuation">;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>需要使用串口2的中断接收数据。通过中断回调函数进行。<br><img src="/img/stm32+esp8266/39.png"></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void <span class="hljs-constructor">HAL_UART_RxCpltCallback(UART_HandleTypeDef <span class="hljs-operator">*</span><span class="hljs-params">huart</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(huart-&gt;Instance<span class="hljs-operator"> == </span>USART2)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(esp8266_cnt &gt;= <span class="hljs-number">512</span>)  <br>        &#123;<br>            esp8266_cnt = <span class="hljs-number">0</span>;<br>            memset(ESP8266_Buf,<span class="hljs-number">0x00</span>,sizeof(ESP8266_Buf));<br>            <span class="hljs-constructor">HAL_UART_Transmit(&amp;<span class="hljs-params">huart2</span>, (<span class="hljs-params">uint8_t</span> <span class="hljs-operator">*</span>)</span><span class="hljs-string">&quot;data overflow&quot;</span>, <span class="hljs-number">10</span>,<span class="hljs-number">0xFFFF</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            ESP8266_Buf<span class="hljs-literal">[<span class="hljs-identifier">esp8266_cnt</span><span class="hljs-operator">++</span>]</span> = a_esp8266_buf;<br>        &#125;<br>        <span class="hljs-constructor">HAL_UART_Receive_IT(&amp;<span class="hljs-params">huart2</span>, (<span class="hljs-params">uint8_t</span> <span class="hljs-operator">*</span>)</span>&amp;a_esp8266_buf, <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，stm32通过esp8266就成功的接入了阿里云。  </p><h2 id="功能定义"><a href="#功能定义" class="headerlink" title="功能定义"></a>功能定义</h2><p>在产品的详情界面中点击功能定义 ，再点击编辑草稿。<br><img src="/img/stm32+esp8266/40.png"><br>点击添加自定义功能添加自己设置的功能模块。<br><img src="/img/stm32+esp8266/41.png"><br>如图。<br><img src="/img/stm32+esp8266/42.png"><br> 添加完成过后记得发布上线，否则不会更新。<br><img src="/img/stm32+esp8266/43.png"></p><h2 id="订阅和发布的Topic"><a href="#订阅和发布的Topic" class="headerlink" title="订阅和发布的Topic"></a>订阅和发布的Topic</h2><p>选择属性上报的第一个作为设备属性上报的Topic。<br><img src="/img/stm32+esp8266/44.png"><br>在C语言中有一个函数可以将字符串按照格式写进数组中。<a href="https://www.runoob.com/cprogramming/c-function-sprintf.html">runoob</a><br>因为 AT+MQTTPUB  这个AT指令只支持256字节以内的消息发送，所以我我们只需要定义一个256个大小的数组去作为我们指令的存储的数组。<br>代码如下：  </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs swift">char data[<span class="hljs-number">256</span>];<br>memset(data, <span class="hljs-number">0</span>, sizeof(data));   <br>sprintf(data,<span class="hljs-string">&quot;AT+MQTTPUB=0,<span class="hljs-subst">\&quot;</span>/sys/hq42unqMiBQ/test/thing/event/property/post<span class="hljs-subst">\&quot;</span>,<span class="hljs-subst">\&quot;</span>&#123;<span class="hljs-subst">\\</span><span class="hljs-subst">\&quot;</span>params<span class="hljs-subst">\\</span><span class="hljs-subst">\&quot;</span>:<span class="hljs-subst">\\</span><span class="hljs-subst">\&quot;</span>LED1<span class="hljs-subst">\\</span><span class="hljs-subst">\&quot;</span>:%d<span class="hljs-subst">\\</span>\,<span class="hljs-subst">\\</span><span class="hljs-subst">\&quot;</span>LED2<span class="hljs-subst">\\</span><span class="hljs-subst">\&quot;</span>:%d&#125;<span class="hljs-subst">\\</span>\,<span class="hljs-subst">\\</span><span class="hljs-subst">\&quot;</span>method<span class="hljs-subst">\\</span><span class="hljs-subst">\&quot;</span>:<span class="hljs-subst">\\</span><span class="hljs-subst">\&quot;</span>thing.event.property.post<span class="hljs-subst">\\</span><span class="hljs-subst">\&quot;</span>&#125;<span class="hljs-subst">\&quot;</span>,0,0<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span>&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">while</span>(<span class="hljs-type">ESP8266_SendCmd</span>(data,<span class="hljs-string">&quot;OK&quot;</span>));<br></code></pre></td></tr></table></figure><p>需要将发送的间隔拉大一些，如下，通过延时函数和计数数将时间拉大到10s发送一次。<br><img src="/img/stm32+esp8266/45.png"><br>将代码烧录之后，运行完成可以在物模型数据看到发送到平台的数据。<br><img src="/img/stm32+esp8266/46.png"></p><h1 id="解析数据"><a href="#解析数据" class="headerlink" title="解析数据"></a>解析数据</h1><h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><p>进入阿里云的IOT Stdio，点击新建项目。<br><img src="/img/stm32+esp8266/47.png"><br>新建项目后点击新建Web应用。<br><img src="/img/stm32+esp8266/48.png"><br>应用名称随便填写<br><img src="/img/stm32+esp8266/49.png"><br>创建完成后我们进入应用。  </p><h2 id="添加应用"><a href="#添加应用" class="headerlink" title="添加应用"></a>添加应用</h2><p>在左侧组件处拖入一个指示灯和一个开关。<br><img src="/img/stm32+esp8266/50.png"></p><h2 id="设置应用"><a href="#设置应用" class="headerlink" title="设置应用"></a>设置应用</h2><p>点击指示灯组件，点击配置数据源<br><img src="/img/stm32+esp8266/51.png"><br>选择我们的产品、数据、和属性。<br><img src="/img/stm32+esp8266/52.png"><br>我们还可以配置开和关的显示颜色。<br><img src="/img/stm32+esp8266/53.png"><br>点击按钮，配置交互动作。<br><img src="/img/stm32+esp8266/54.png"><br>选择设备和属性，设置值位置点击数据来源，选择组件值<br><img src="/img/stm32+esp8266/55.png"><br>配置完成后进入预览，点击按钮，在esp8266就会收到来自平台的json格式的数据，MCU端需要做的就是解析来自平台的数据，进而达到控制下位机的目的。  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">+MQTTSUBRECV:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;/sys/hq42unqMiBQ/test/thing/service/property/set&quot;</span>,<span class="hljs-number">101</span>,<br>&#123;&quot;method&quot;:<span class="hljs-string">&quot;thing.service.property.set&quot;</span>,<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-string">&quot;2067652254&quot;</span>,<span class="hljs-string">&quot;params&quot;</span>:<br>&#123;&quot;LEDSwitch1&quot;:<span class="hljs-number">1</span>&#125;,&quot;version&quot;:<span class="hljs-string">&quot;1.0.0&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>我们需要解析的是 “params” 后面的数据，但是这个数据的长短不一，是根据自己设置的模型来的。所以我我们在解析的时候就利用这一特性，直接解析。<br>打开一个定时器，定时1ms。<br><img src="/img/stm32+esp8266/56.png"><br>打开中断。<br><img src="/img/stm32+esp8266/57.png"><br>在之前工程的基础上，生成新的工程。<br>打开定时器中断。  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">HAL_TIM_Base_Start_IT(&amp;<span class="hljs-params">htim7</span>)</span>;<br></code></pre></td></tr></table></figure><p>重写回调函数。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs awk">void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) <span class="hljs-regexp">//</span>中断回调函数<br>&#123;<br>    static uint16_t dis_cnt,flash_cnt;<br>    <span class="hljs-keyword">if</span>( htim -&gt; Instance == TIM7)<span class="hljs-regexp">//</span>定时器<span class="hljs-number">7</span><br>    &#123;<br>        dis_cnt++;<br>        <span class="hljs-keyword">if</span>(dis_cnt==<span class="hljs-number">5</span>)<span class="hljs-regexp">//</span>延时<span class="hljs-number">5</span>ms<br>        &#123;<br>            dis_cnt=<span class="hljs-number">0</span>;<br>            wait_flag=<span class="hljs-number">1</span>;<span class="hljs-regexp">//</span>解析延时标志位<br>        &#125;<br>        flash_cnt++;<br>        <span class="hljs-keyword">if</span>(flash_cnt==<span class="hljs-number">2000</span>)<span class="hljs-regexp">//</span>显示延时<br>        &#123;<br>            flash_flag=<span class="hljs-number">1</span>;<span class="hljs-regexp">//</span>显示延时标志位<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里使用的是非阻塞的延时，如果是直接使用HAL_Delay的话，会影响其它的函数进行，所以在定时器7中的延时标志位就是用于这个地方。  </p><h2 id="解析函数"><a href="#解析函数" class="headerlink" title="解析函数"></a>解析函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-title">ESP8266_rx</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> timeOut)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//char buf[20];</span><br>    <span class="hljs-type">char</span> *ptrIPD = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">char</span> *ptrIPD_2 = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">char</span> *ptrIPD_3 = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">char</span> *ptrIPD_4 = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">int</span> i = timeOut;<br>    <span class="hljs-keyword">if</span>( i &amp;&amp; wait_flag)<br>    &#123;<br>        wait_flag=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">ESP8266_WaitRecive</span>() == OK)<span class="hljs-comment">//如果接收完成</span><br>        &#123;<br>            ptrIPD = <span class="hljs-built_in">strstr</span>((<span class="hljs-type">char</span> *)ESP8266_Buf,<span class="hljs-string">&quot;params&quot;</span>);<span class="hljs-comment">//搜索标识符头</span><br>            <span class="hljs-keyword">if</span>(ptrIPD == <span class="hljs-literal">NULL</span>)<span class="hljs-comment">//如果没找到，可能是标识符头的延迟，还是需要等待一会，但不会超过设定的时间</span><br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//没有找到则返回0</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                ptrIPD = <span class="hljs-built_in">strchr</span>(ptrIPD, <span class="hljs-string">&#x27;:&#x27;</span>);<span class="hljs-comment">//找到params后面的&#x27;  : &#x27;</span><br>                <span class="hljs-keyword">if</span>(ptrIPD != <span class="hljs-literal">NULL</span>)<br>                &#123;<br>                    ptrIPD+=<span class="hljs-number">3</span>;<span class="hljs-comment">//找到: 后地址向后移动三位，就是标识符，</span><br>                    ptrIPD_2 = <span class="hljs-built_in">strchr</span>(ptrIPD, <span class="hljs-string">&#x27;:&#x27;</span>); <span class="hljs-comment">//在标识符的后方第一个:就是标识符的值</span><br>                    <span class="hljs-keyword">if</span> (ptrIPD!=<span class="hljs-literal">NULL</span>)<br>                    &#123;<br>                        <span class="hljs-built_in">memset</span>(buf,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(buf));<br>                        ptrIPD_2++;<br>                        buf[<span class="hljs-number">0</span>]=*ptrIPD_2;<br>                        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">atoi</span>(buf)==<span class="hljs-number">1</span>)<br>                        &#123;<br>                            flag_buf=<span class="hljs-number">1</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span><br>                        &#123;<br>                            flag_buf=<span class="hljs-number">0</span>;<br>                        &#125;<br>                    &#125;<br>                    ptrIPD_3 = <span class="hljs-built_in">strchr</span>(ptrIPD, <span class="hljs-string">&#x27;:&#x27;</span>);<span class="hljs-comment">//解析标识符</span><br>                    <span class="hljs-keyword">if</span> (ptrIPD!=<span class="hljs-literal">NULL</span>)<br>                    &#123;<br>                        <span class="hljs-built_in">memset</span>(buf,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(buf));<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">20</span>; i&gt;=<span class="hljs-number">0</span>;i--)<br>                        &#123;<br>                            buf[<span class="hljs-number">20</span>-i]=*(ptrIPD_3-i);<br>                            <span class="hljs-keyword">if</span>(buf[<span class="hljs-number">20</span>-i]==<span class="hljs-string">&#x27;&#123;&#x27;</span>)<br>                            &#123;<br>                                ptrIPD_4=(ptrIPD_3-i+<span class="hljs-number">2</span>);<br>                                <span class="hljs-built_in">memset</span>(buf,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(buf));<br>                                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">20</span>;j++)<br>                                &#123;<br>                                    buf[j]=*(ptrIPD_4+j);<br>                                    <span class="hljs-keyword">if</span>(buf[j]==<span class="hljs-string">&#x27;&quot;&#x27;</span>)<br>                                    &#123;<br>                                        buf[j]=<span class="hljs-number">0</span>;<br>                                        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> ;<br>                                    &#125;<br>                                &#125;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        i--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//超时还未找到，返回0</span><br></code></pre></td></tr></table></figure><p>在判断的时候只需要使用下方函数进行判断，这样子就不会影响在多个标识符时，出现大概率的失误。<br><a href="https://www.runoob.com/cprogramming/c-strings.html">strcmp runoob</a><br>只需要进行下方的判断  </p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">if(!(<span class="hljs-name">strcmp</span>(<span class="hljs-name">buf</span>,<span class="hljs-string">&quot;LED1&quot;</span>)))<br></code></pre></td></tr></table></figure><p>将按钮的值和灯的值绑定。点击按钮配置数据源。<br><img src="/img/stm32+esp8266/58.png"><br>在预览中点击按钮，esp8266接收到如下的数据。所以如果是绑定了数据源，所以改变按钮1的值就下发关于LED的数据。  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">+MQTTSUBRECV:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;/sys/hq42unqMiBQ/test/thing/service/property/set&quot;</span>,<span class="hljs-number">95</span>,<br>&#123;&quot;method&quot;:<span class="hljs-string">&quot;thing.service.property.set&quot;</span>,<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-string">&quot;1433329632&quot;</span>,<span class="hljs-string">&quot;params&quot;</span>:<br>&#123;&quot;LED1&quot;:<span class="hljs-number">0</span>&#125;,&quot;version&quot;:<span class="hljs-string">&quot;1.0.0&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>解析后将LED1的数据上报到云。  </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">if</span>(<span class="hljs-operator">!</span>(strcmp(buf,<span class="hljs-string">&quot;LED1&quot;</span>)))<br>      &#123;<br>          memset(buf, <span class="hljs-number">0</span>, sizeof(buf));<br>          <span class="hljs-keyword">if</span>(flag_buf <span class="hljs-operator">==</span> <span class="hljs-number">1</span> )<br>          &#123;<br>              led_info.led1<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br>              memset(data, <span class="hljs-number">0</span>, sizeof(data));<br>              sprintf(data,<span class="hljs-string">&quot;AT+MQTTPUB=0,<span class="hljs-subst">\&quot;</span>/sys/hq42unqMiBQ/test/thing/event/property/post<span class="hljs-subst">\&quot;</span>,<span class="hljs-subst">\&quot;</span>&#123;\</span><br><span class="hljs-string"><span class="hljs-subst">\\</span><span class="hljs-subst">\&quot;</span>params<span class="hljs-subst">\\</span><span class="hljs-subst">\&quot;</span>:&#123;<span class="hljs-subst">\\</span><span class="hljs-subst">\&quot;</span>LED1<span class="hljs-subst">\\</span><span class="hljs-subst">\&quot;</span>:%d&#125;<span class="hljs-subst">\\</span>\,\</span><br><span class="hljs-string"><span class="hljs-subst">\\</span><span class="hljs-subst">\&quot;</span>method<span class="hljs-subst">\\</span><span class="hljs-subst">\&quot;</span>:<span class="hljs-subst">\\</span><span class="hljs-subst">\&quot;</span>thing.event.property.post<span class="hljs-subst">\\</span><span class="hljs-subst">\&quot;</span>&#125;<span class="hljs-subst">\&quot;</span>,0,0<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span>&quot;</span>,led_info.led1);<br>              <span class="hljs-keyword">while</span>(<span class="hljs-type">ESP8266_SendCmd</span>(data,<span class="hljs-string">&quot;OK&quot;</span>));<br>              <span class="hljs-type">ESP8266_Clear</span>();<br>          &#125;<br>          <span class="hljs-keyword">else</span><br>          &#123;<br>              led_info.led1<span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br>              memset(data, <span class="hljs-number">0</span>, sizeof(data));<br>              sprintf(data,<span class="hljs-string">&quot;AT+MQTTPUB=0,<span class="hljs-subst">\&quot;</span>/sys/hq42unqMiBQ/test/thing/event/property/post<span class="hljs-subst">\&quot;</span>,<span class="hljs-subst">\&quot;</span>&#123;\</span><br><span class="hljs-string"><span class="hljs-subst">\\</span><span class="hljs-subst">\&quot;</span>params<span class="hljs-subst">\\</span><span class="hljs-subst">\&quot;</span>:&#123;<span class="hljs-subst">\\</span><span class="hljs-subst">\&quot;</span>LED1<span class="hljs-subst">\\</span><span class="hljs-subst">\&quot;</span>:%d&#125;<span class="hljs-subst">\\</span>\,\</span><br><span class="hljs-string"><span class="hljs-subst">\\</span><span class="hljs-subst">\&quot;</span>method<span class="hljs-subst">\\</span><span class="hljs-subst">\&quot;</span>:<span class="hljs-subst">\\</span><span class="hljs-subst">\&quot;</span>thing.event.property.post<span class="hljs-subst">\\</span><span class="hljs-subst">\&quot;</span>&#125;<span class="hljs-subst">\&quot;</span>,0,0<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span>&quot;</span>,led_info.led1);<br>              <span class="hljs-keyword">while</span>(<span class="hljs-type">ESP8266_SendCmd</span>(data,<span class="hljs-string">&quot;OK&quot;</span>));<br>              <span class="hljs-type">ESP8266_Clear</span>();<br>          &#125;<br>      &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
      <tag>ESP</tag>
      
      <tag>云</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32无线烧录器</title>
    <link href="/2022/12/30/STM32%E6%97%A0%E7%BA%BF%E7%83%A7%E5%BD%95%E5%99%A8/"/>
    <url>/2022/12/30/STM32%E6%97%A0%E7%BA%BF%E7%83%A7%E5%BD%95%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="STM32无线烧录器Part1"><a href="#STM32无线烧录器Part1" class="headerlink" title="STM32无线烧录器Part1"></a>STM32无线烧录器Part1</h1><h2 id="下载固件"><a href="#下载固件" class="headerlink" title="下载固件"></a>下载固件</h2><p><em>使用合宙的ESP32c3烧录固件wireless-DAPLINK-LuatOS-ESP32C3_USB.soc ，在这个固件中默认链接 Wi-Fi配置会自动连接名为DAP，密码为12345678的Wi-Fi。</em><br><strong>Luatostools下载：<a href="https://wiki.luatos.com/boardGuide/flash.html">luatostools</a></strong><br><em>因为打开exe文件后会下载一些包，所以最好新建一个文件夹再打开。</em>  </p><p><img src="/img/STM32_photo/0.png"><br>固件下载  </p><p><img src="/img/STM32_photo/1.png"><br><img src="/img/STM32_photo/2.png"><br><em>固件烧录完成后，电脑打开热点，将热点名称设置为<br><font color ="dd0000">DAP</font>,密码设置为<br><font color ="dd0000">12345678</font><br>并且 频段只能是2.4G</em>  </p><h2 id="使用-elaphureLink"><a href="#使用-elaphureLink" class="headerlink" title="使用 elaphureLink"></a>使用 elaphureLink</h2><p>打开热点管理，将esp通电后会链接热点，连接后会显示ip<br><img src="/img/STM32_photo/3.png"><br>打开elaphureLink，将ip添入Device Address<br><img src="/img/STM32_photo/4.png"><br>点击下方install，将驱动安装到Keil下，这个路径一定要对，不然识别不了。<br>点击Start Proxy 右边的小按钮打开<br><font color ="dd0000">在使用期间elaphureLink不可关闭。</font>  </p><h2 id="keil"><a href="#keil" class="headerlink" title="keil"></a>keil</h2><p>打开keil 选择魔法棒，再点击debug，选择 <font color ="dd0000">elaphureLink Debugger</font><br><img src="/img/STM32_photo/5.png"><br>点击setting 如下图设置。（如果点不开，那就把elaphureLink关闭，打开setting后再打开）<br><img src="/img/STM32_photo/6.png">  </p><h2 id="接线"><a href="#接线" class="headerlink" title="接线"></a>接线</h2><p><img src="/img/STM32_photo/7.png"><br>分别接在STM32对应的位置<br><img src="/img/STM32_photo/8.png"><br><img src="/img/STM32_photo/9.png">  </p><h1 id="STM32无线烧录器Part2"><a href="#STM32无线烧录器Part2" class="headerlink" title="STM32无线烧录器Part2"></a>STM32无线烧录器Part2</h1><p>继上次完成了ESP32无线烧录器。那么有一个问题就是，一堆人都在一起想用这个来无线烧录呢，那么固件中定死的热点名称岂不是会互相的扰乱。所以需要自己编译属于自己的热点名称。<br>首先需要准备以下几样东西。<br>Ubuntu （需要安装idf），这里默认你拥有。<br>ESP32C3，同样默认拥有。合宙简约版esp32c3即可。<br>无限烧录的源码。传送门：<a href="https://github.com/windowsair/wireless-esp8266-dap">wireles-dap</a>  </p><h2 id="安装IDF"><a href="#安装IDF" class="headerlink" title="安装IDF"></a>安装IDF</h2><p>由于网速原因，这里不通过克隆的方式进行下载。<br><a href="https://github.com/espressif/esp-idf/releases/tag/v4.4.2">esp-idf</a><br><img src="/img/STM32_photo/10.png"><br>点击这个连接进行下载。在下载的间隙，先做一下准备工作，新建文件夹。  </p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">~ <span class="hljs-variable">$</span> mkdir esp  <br>~ <span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span>  esp/  <br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">~ $ sudo apt-<span class="hljs-built_in">get</span> update<br>~ $ sudo apt-<span class="hljs-built_in">get</span><span class="hljs-built_in"> upgrade</span><br><span class="hljs-built_in"></span>~ $ sudo apt-<span class="hljs-built_in">get</span> install git wget flex bison gperf python3 python3-venv python3-setuptools cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0<br></code></pre></td></tr></table></figure><p>下载完成后通过复制到Ubuntu下的esp文件夹中。  </p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">~/esp <span class="hljs-symbol">$mv</span> esp-idf-v4<span class="hljs-number">.4</span><span class="hljs-number">.2</span>  esp-idf<br>~<span class="hljs-regexp">/esp $cd esp-idf/</span><br>~<span class="hljs-regexp">/esp/</span>esp-idf <span class="hljs-symbol">$e</span>xport IDF_GITHUB_ASSETS=<span class="hljs-string">&quot;dl.espressif.com/github_assets&quot;</span><br>~<span class="hljs-regexp">/esp/</span>esp-idf $./install.sh<br></code></pre></td></tr></table></figure><p><img src="/img/STM32_photo/11.png">  </p><p>出现这一行就说明成功了。  </p><p><img src="/img/STM32_photo/12.png">  </p><p>将源码解压放到esp文件夹下。  </p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><h3 id="完善源码文件"><a href="#完善源码文件" class="headerlink" title="完善源码文件"></a>完善源码文件</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">~ <span class="hljs-variable">$cd</span> ~<span class="hljs-regexp">/esp/</span>wireless-esp8266-dap/components<br>git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/windowsair/</span>corsacOTA.git<br>~ <span class="hljs-variable">$cd</span> ~<span class="hljs-regexp">/esp/</span>wireless-esp8266-dap/<br>git clone  https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/windowsair/</span>ESP8266_RTOS_SDK.git<br></code></pre></td></tr></table></figure><h3 id="Udev-规则"><a href="#Udev-规则" class="headerlink" title="Udev 规则"></a>Udev 规则</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">~ <span class="hljs-variable">$sudo</span> gedit <span class="hljs-regexp">/etc/u</span>dev<span class="hljs-regexp">/rules.d/</span><span class="hljs-number">40</span>-dfuse.rules<br></code></pre></td></tr></table></figure><p>写入</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">SUBSYSTEMS</span>==&quot;usb&quot;, ATTRS&#123;idVendor&#125;==<span class="hljs-string">&quot;303a&quot;</span>, ATTRS&#123;idProduct&#125;==<span class="hljs-string">&quot;00??&quot;</span>, <span class="hljs-attribute">GROUP</span>=<span class="hljs-string">&quot;plugdev&quot;</span>, <span class="hljs-attribute">MODE</span>=<span class="hljs-string">&quot;0666&quot;</span> <br></code></pre></td></tr></table></figure><p>手动重启</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo udevadm trigger</span><br></code></pre></td></tr></table></figure><h3 id="准备编译"><a href="#准备编译" class="headerlink" title="准备编译"></a>准备编译</h3><p>进入源码文件夹</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">~ <span class="hljs-symbol">$cd</span> ~<span class="hljs-regexp">/esp/</span>wireless-esp8266-dap<br></code></pre></td></tr></table></figure><p>设置环境变量</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">~<span class="hljs-regexp">/esp/</span>wireless-esp8266-dap $ . <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/esp/</span>esp-idf/export.sh<br></code></pre></td></tr></table></figure><p>出现下方红色线极为正常。<br><img src="/img/STM32_photo/13.png">  </p><h3 id="设置目标芯片"><a href="#设置目标芯片" class="headerlink" title="设置目标芯片"></a>设置目标芯片</h3><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig">~/<span class="hljs-string">esp</span>/<span class="hljs-string">wireless-esp8266-dap</span> $ <span class="hljs-string">idf</span>.<span class="hljs-string">py</span> <span class="hljs-built_in">set-target</span> <span class="hljs-string">esp32c3</span><br></code></pre></td></tr></table></figure><p>如下方所示即为正常。<br><img src="/img/STM32_photo/14.png">  </p><h3 id="配置为USB烧录"><a href="#配置为USB烧录" class="headerlink" title="配置为USB烧录"></a>配置为USB烧录</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">~<span class="hljs-regexp">/esp/</span>wireless-esp8266-dap $ idf.py menuconfig<br></code></pre></td></tr></table></figure><p>进入如下路径选择USB烧录。  </p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl">C<span class="hljs-function"><span class="hljs-title">omponent</span>-&gt;</span>ESP S<span class="hljs-function"><span class="hljs-title">ystem</span> Settings -&gt;</span>C<span class="hljs-function"><span class="hljs-title">hannel</span> <span class="hljs-keyword">for</span> console output-&gt;</span>USB Serial/JTAG Controller<br></code></pre></td></tr></table></figure><p>一直ESC直到出现如下界面，按Y保存。<br><img src="/img/STM32_photo/15.png">  </p><h3 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">~<span class="hljs-regexp">/esp/</span>wireless-esp8266-dap $ idf.py build<br></code></pre></td></tr></table></figure><p>如下现象即为成功。<br><img src="/img/STM32_photo/16.png">  </p><h2 id="烧录"><a href="#烧录" class="headerlink" title="烧录"></a>烧录</h2><p>将开发板插上电。虚拟机会弹出这个界面。选择连接到虚拟机。<br><img src="/img/STM32_photo/17.png"><br>查看USB设备在不在。  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">ls <span class="hljs-regexp">/dev/</span>ttyACM<br></code></pre></td></tr></table></figure><p>命令行出现ttyACM设备就是正常的。<br>给权限。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo chmod <span class="hljs-number">777</span> <span class="hljs-regexp">/dev/</span>ttyACM0<br></code></pre></td></tr></table></figure><p>烧录</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">~<span class="hljs-regexp">/esp/</span>wireless-esp8266-dap $ idf.py -p <span class="hljs-regexp">/dev/</span>ttyACM0 flash<br></code></pre></td></tr></table></figure><p>出现进度条就说明正在烧录<br><img src="/img/STM32_photo/18.png"><br>出现以下现象则说明烧录成功。<br><img src="/img/STM32_photo/19.png"><br>电脑打开热点即可查看是否成功。<br><img src="/img/STM32_photo/20.png">  </p><h2 id="修改连接热点名称"><a href="#修改连接热点名称" class="headerlink" title="修改连接热点名称"></a>修改连接热点名称</h2><p>打开源码目录下的 main&#x2F; wifi_configuration.h<br><img src="/img/STM32_photo/21.png"><br>修改划线处即可。  </p><h2 id="重新编译烧录。"><a href="#重新编译烧录。" class="headerlink" title="重新编译烧录。"></a>重新编译烧录。</h2><p><img src="/img/STM32_photo/22.png">  </p>]]></content>
    
    
    <categories>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
